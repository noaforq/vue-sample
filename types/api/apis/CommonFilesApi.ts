/* tslint:disable */
/* eslint-disable */
/**
 * TechFUL API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiError,
  ChatFileDownloadIn,
  FileDetailOut,
  ValidationError,
} from '../models/index';
import {
    ApiErrorFromJSON,
    ApiErrorToJSON,
    ChatFileDownloadInFromJSON,
    ChatFileDownloadInToJSON,
    FileDetailOutFromJSON,
    FileDetailOutToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models/index';

export interface ObtainChatFileUrlRequest {
    chatFileDownloadIn: ChatFileDownloadIn;
}

export interface UploadFileRequest {
    files: Array<Blob>;
    dir: string;
    extension?: string;
    _private?: boolean;
}

export interface UploadFileJudgeRequest {
    files: Array<Blob>;
    dir?: string;
}

/**
 * 
 */
export class CommonFilesApi extends runtime.BaseAPI {

    /**
     * チャットファイルダウンロードURL発行 - ダウンロード可能条件     - 自身所属するチャットルーム         - 企業、スタッフの場合は組織単位         - 学校、一般ユーザーの場合は個人単位
     * チャットファイルダウンロードURL発行
     */
    async obtainChatFileUrlRaw(requestParameters: ObtainChatFileUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileDetailOut>> {
        if (requestParameters.chatFileDownloadIn === null || requestParameters.chatFileDownloadIn === undefined) {
            throw new runtime.RequiredError('chatFileDownloadIn','Required parameter requestParameters.chatFileDownloadIn was null or undefined when calling obtainChatFileUrl.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/common/files/chat-files/download-urls`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChatFileDownloadInToJSON(requestParameters.chatFileDownloadIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileDetailOutFromJSON(jsonValue));
    }

    /**
     * チャットファイルダウンロードURL発行 - ダウンロード可能条件     - 自身所属するチャットルーム         - 企業、スタッフの場合は組織単位         - 学校、一般ユーザーの場合は個人単位
     * チャットファイルダウンロードURL発行
     */
    async obtainChatFileUrl(requestParameters: ObtainChatFileUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileDetailOut> {
        const response = await this.obtainChatFileUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * ファイルアップロード
     * ファイルアップロード
     */
    async uploadFileRaw(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FileDetailOut>>> {
        if (requestParameters.files === null || requestParameters.files === undefined) {
            throw new runtime.RequiredError('files','Required parameter requestParameters.files was null or undefined when calling uploadFile.');
        }

        if (requestParameters.dir === null || requestParameters.dir === undefined) {
            throw new runtime.RequiredError('dir','Required parameter requestParameters.dir was null or undefined when calling uploadFile.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.files) {
            requestParameters.files.forEach((element) => {
                formParams.append('files', element as any);
            })
        }

        if (requestParameters.dir !== undefined) {
            formParams.append('dir', requestParameters.dir as any);
        }

        if (requestParameters.extension !== undefined) {
            formParams.append('extension', requestParameters.extension as any);
        }

        if (requestParameters._private !== undefined) {
            formParams.append('private', requestParameters._private as any);
        }

        const response = await this.request({
            path: `/common/files/upload`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FileDetailOutFromJSON));
    }

    /**
     * ファイルアップロード
     * ファイルアップロード
     */
    async uploadFile(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FileDetailOut>> {
        const response = await this.uploadFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 事前配置ファイルをジャッジのバケットにアップロード
     * 事前配置ファイルアップロード
     */
    async uploadFileJudgeRaw(requestParameters: UploadFileJudgeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FileDetailOut>>> {
        if (requestParameters.files === null || requestParameters.files === undefined) {
            throw new runtime.RequiredError('files','Required parameter requestParameters.files was null or undefined when calling uploadFileJudge.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.files) {
            requestParameters.files.forEach((element) => {
                formParams.append('files', element as any);
            })
        }

        if (requestParameters.dir !== undefined) {
            formParams.append('dir', requestParameters.dir as any);
        }

        const response = await this.request({
            path: `/common/files/upload/judge-data`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FileDetailOutFromJSON));
    }

    /**
     * 事前配置ファイルをジャッジのバケットにアップロード
     * 事前配置ファイルアップロード
     */
    async uploadFileJudge(requestParameters: UploadFileJudgeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FileDetailOut>> {
        const response = await this.uploadFileJudgeRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
