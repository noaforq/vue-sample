/* tslint:disable */
/* eslint-disable */
/**
 * TechFUL API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiError,
  AppRoutersManageQuestionsGetQuestionListOrdering,
  BugCodeRegisterIn,
  BugCodeRegistrationResultOut,
  ContentCreatedByOut,
  ContentDivision,
  ContentTagOut,
  DownloadType,
  QuestionCreateIn,
  QuestionDetailOut,
  QuestionEnglishTextUpdateIn,
  QuestionFormatCheckResultOut,
  QuestionListDetailOut,
  QuestionListOut,
  QuestionPublishIn,
  QuestionTestCaseExecuteIn,
  QuestionTestCaseExecuteOut,
  QuestionTestCasesListOut,
  QuestionType,
  QuestionUpdateIn,
  QuestionVerificationListOut,
  QuestionVerificationResultOut,
  ValidationError,
} from '../models/index';
import {
    ApiErrorFromJSON,
    ApiErrorToJSON,
    AppRoutersManageQuestionsGetQuestionListOrderingFromJSON,
    AppRoutersManageQuestionsGetQuestionListOrderingToJSON,
    BugCodeRegisterInFromJSON,
    BugCodeRegisterInToJSON,
    BugCodeRegistrationResultOutFromJSON,
    BugCodeRegistrationResultOutToJSON,
    ContentCreatedByOutFromJSON,
    ContentCreatedByOutToJSON,
    ContentDivisionFromJSON,
    ContentDivisionToJSON,
    ContentTagOutFromJSON,
    ContentTagOutToJSON,
    DownloadTypeFromJSON,
    DownloadTypeToJSON,
    QuestionCreateInFromJSON,
    QuestionCreateInToJSON,
    QuestionDetailOutFromJSON,
    QuestionDetailOutToJSON,
    QuestionEnglishTextUpdateInFromJSON,
    QuestionEnglishTextUpdateInToJSON,
    QuestionFormatCheckResultOutFromJSON,
    QuestionFormatCheckResultOutToJSON,
    QuestionListDetailOutFromJSON,
    QuestionListDetailOutToJSON,
    QuestionListOutFromJSON,
    QuestionListOutToJSON,
    QuestionPublishInFromJSON,
    QuestionPublishInToJSON,
    QuestionTestCaseExecuteInFromJSON,
    QuestionTestCaseExecuteInToJSON,
    QuestionTestCaseExecuteOutFromJSON,
    QuestionTestCaseExecuteOutToJSON,
    QuestionTestCasesListOutFromJSON,
    QuestionTestCasesListOutToJSON,
    QuestionTypeFromJSON,
    QuestionTypeToJSON,
    QuestionUpdateInFromJSON,
    QuestionUpdateInToJSON,
    QuestionVerificationListOutFromJSON,
    QuestionVerificationListOutToJSON,
    QuestionVerificationResultOutFromJSON,
    QuestionVerificationResultOutToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models/index';

export interface CreateQuestionRequest {
    questionCreateIn: QuestionCreateIn;
}

export interface CreateQuestionCopyRequest {
    contentId: number;
}

export interface DeleteQuestionRequest {
    contentId: number;
}

export interface DownloadTestCaseRequest {
    contentId: number;
    downloadType?: DownloadType;
}

export interface ExecuteFormatCheckRequest {
    contentId: number;
}

export interface ExecuteQuestionTestCaseRequest {
    contentId: number;
    questionTestCaseExecuteIn: QuestionTestCaseExecuteIn;
}

export interface GetBugCodeRegistrationResultRequest {
    contentId: number;
}

export interface GetContentCreatedByRequest {
    isGeneral?: boolean;
    isProQuestion?: boolean;
    isMaterial?: boolean;
    isTechthon?: boolean;
}

export interface GetContentTagsRequest {
    isGeneral?: boolean;
    isProQuestion?: boolean;
    isMaterial?: boolean;
    isTechthon?: boolean;
}

export interface GetQuestionRequest {
    contentId: number;
}

export interface GetQuestionForEventRequest {
    contentId: number;
}

export interface GetQuestionListRequest {
    limit?: number;
    offset?: number;
    contentId?: number;
    name?: string;
    questionTypes?: Array<QuestionType>;
    contentDivisions?: Array<ContentDivision>;
    contentCategoryIds?: Array<number>;
    difficulties?: Array<number>;
    tags?: Array<number>;
    isVerified?: boolean;
    isFavorite?: boolean;
    isOfficial?: boolean;
    isOriginalPrivate?: boolean;
    isOriginalOtherSchoolsPublic?: boolean;
    isStock?: boolean;
    isSharedSchoolsTestcases?: boolean;
    isSharedSchoolsNoneTestcases?: boolean;
    createdBy?: Array<string>;
    orderBy?: AppRoutersManageQuestionsGetQuestionListOrdering;
}

export interface GetQuestionListForEventRequest {
    contentId?: number;
    name?: string;
    questionTypes?: Array<QuestionType>;
    contentCategoryIds?: Array<number>;
    difficulties?: Array<number>;
    tags?: Array<number>;
    isFavorite?: boolean;
    isOfficial?: boolean;
    isSharedBetweenSchools?: boolean;
    createdBy?: Array<string>;
}

export interface GetQuestionTestCaseExecutionResultsRequest {
    contentId: number;
    questionVerificationResultId: number;
    isLastQuery?: boolean;
}

export interface GetQuestionTestCasesRequest {
    contentId: number;
    isSampleCase?: boolean;
}

export interface GetQuestionVerificationListRequest {
    contentId: number;
    other?: boolean;
}

export interface PublishQuestionRequest {
    questionPublishIn: Array<QuestionPublishIn>;
}

export interface RegisterBugCodeRequest {
    contentId: number;
    bugCodeRegisterIn: BugCodeRegisterIn;
}

export interface UpdateQuestionRequest {
    contentId: number;
    questionUpdateIn: QuestionUpdateIn;
}

export interface UpdateQuestionEnglishTextRequest {
    contentId: number;
    questionEnglishTextUpdateIn: QuestionEnglishTextUpdateIn;
}

/**
 * 
 */
export class ManageQuestionsApi extends runtime.BaseAPI {

    /**
     * 問題作成 - 必要権限：[PROBLEM_EDIT] - 登録データ補足情報     - is_official: スタッフの場合True     - organization: 自組織     - created_by: user.full_name     - content_type: ContentType.GENERAL(一般問題・教材)
     * 問題作成
     */
    async createQuestionRaw(requestParameters: CreateQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionDetailOut>> {
        if (requestParameters.questionCreateIn === null || requestParameters.questionCreateIn === undefined) {
            throw new runtime.RequiredError('questionCreateIn','Required parameter requestParameters.questionCreateIn was null or undefined when calling createQuestion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/manage/questions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionCreateInToJSON(requestParameters.questionCreateIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionDetailOutFromJSON(jsonValue));
    }

    /**
     * 問題作成 - 必要権限：[PROBLEM_EDIT] - 登録データ補足情報     - is_official: スタッフの場合True     - organization: 自組織     - created_by: user.full_name     - content_type: ContentType.GENERAL(一般問題・教材)
     * 問題作成
     */
    async createQuestion(requestParameters: CreateQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionDetailOut> {
        const response = await this.createQuestionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題コピー作成
     * 問題コピー作成
     */
    async createQuestionCopyRaw(requestParameters: CreateQuestionCopyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionDetailOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling createQuestionCopy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/{content_id}/copy`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionDetailOutFromJSON(jsonValue));
    }

    /**
     * 問題コピー作成
     * 問題コピー作成
     */
    async createQuestionCopy(requestParameters: CreateQuestionCopyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionDetailOut> {
        const response = await this.createQuestionCopyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題の削除 - 必要権限：[PROBLEM_EDIT] - 論理削除 - 自組織が作成した問題のみ削除可能対象とする
     * 問題削除
     */
    async deleteQuestionRaw(requestParameters: DeleteQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling deleteQuestion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/{content_id}`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 問題の削除 - 必要権限：[PROBLEM_EDIT] - 論理削除 - 自組織が作成した問題のみ削除可能対象とする
     * 問題削除
     */
    async deleteQuestion(requestParameters: DeleteQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteQuestionRaw(requestParameters, initOverrides);
    }

    /**
     * テストケースダウンロード - 必要権限: [PROBLEM_VIEW] - ダウンロードファイル形式: download_type     -  `All`: テストケース・サンプルケースの全て         - `cases_<ContentID>.zip`     -  `Test`: テストケースのみ         - `test-cases_<ContentID>.zip`     - `Sample`: サンプルケースのみ         - `sample-cases_<ContentID>.zip` - ダウンロードファイル名:     - SampleCase(01~05)         - sample01_input.txt         - sample01_expected.txt     - TestCase(01~10)         - test01_input_<TestCaseName>.txt         - test01_expected_<TestCaseName>.txt
     * テストケースダウンロード
     */
    async downloadTestCaseRaw(requestParameters: DownloadTestCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling downloadTestCase.');
        }

        const queryParameters: any = {};

        if (requestParameters.downloadType !== undefined) {
            queryParameters['download_type'] = requestParameters.downloadType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/{content_id}/test-cases/download`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * テストケースダウンロード - 必要権限: [PROBLEM_VIEW] - ダウンロードファイル形式: download_type     -  `All`: テストケース・サンプルケースの全て         - `cases_<ContentID>.zip`     -  `Test`: テストケースのみ         - `test-cases_<ContentID>.zip`     - `Sample`: サンプルケースのみ         - `sample-cases_<ContentID>.zip` - ダウンロードファイル名:     - SampleCase(01~05)         - sample01_input.txt         - sample01_expected.txt     - TestCase(01~10)         - test01_input_<TestCaseName>.txt         - test01_expected_<TestCaseName>.txt
     * テストケースダウンロード
     */
    async downloadTestCase(requestParameters: DownloadTestCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadTestCaseRaw(requestParameters, initOverrides);
    }

    /**
     * フォーマットチェック実行 - 必要権限:[PROBLEM_EDIT] - コンテンツ区分がコーディング, 穴埋め, バグ取り問題のみAPIが実行できる - フォーマットチェック結果件数を返す(ex. 正答件数/全件数) - チェック成功時: \"検証OK\"を返す - チェック失敗時: 該当したフォーマットエラー文全てを返す
     * フォーマットチェック実行
     */
    async executeFormatCheckRaw(requestParameters: ExecuteFormatCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionFormatCheckResultOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling executeFormatCheck.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/{content_id}/format_check`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionFormatCheckResultOutFromJSON(jsonValue));
    }

    /**
     * フォーマットチェック実行 - 必要権限:[PROBLEM_EDIT] - コンテンツ区分がコーディング, 穴埋め, バグ取り問題のみAPIが実行できる - フォーマットチェック結果件数を返す(ex. 正答件数/全件数) - チェック成功時: \"検証OK\"を返す - チェック失敗時: 該当したフォーマットエラー文全てを返す
     * フォーマットチェック実行
     */
    async executeFormatCheck(requestParameters: ExecuteFormatCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionFormatCheckResultOut> {
        const response = await this.executeFormatCheckRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題管理者が問題の検証用のためにテストケースを実行する - ジャッジシステムにリクエストを送信   - リクエストデータ     - pg_lang: リクエストボディ     - source_code: リクエストボディ     - JudgeType.VERIFICATION(問題検証)     - judge_code: QuestionVerificationResult(問題テストケース別検証結果).id     - gcs_file_paths: filename(ファイル名), url(ファイルURL)     - test_case_id_list     - original_case_list: 空のリスト - API実行時DB登録データ   - QuestionVerificationResult(問題テストケース別検証結果)     - question_id     - user_id     - pg_lang_id     - source_code     - total_test_case_count   - QuestionVerificationCaseResult(問題テストケース別検証結果)     - question_verification_result_id(問題検証結果ID)     - question_test_case_id(問題テストケースID) - 例外処理   - プログラミング言語が存在しない場合DataDoesNotExist   - コンテンツまたは問題が存在しない場合NotFound   - テストケース(サンプルケース含む)が存在しない場合NotFound
     * 検証用テストケース実行
     */
    async executeQuestionTestCaseRaw(requestParameters: ExecuteQuestionTestCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionTestCaseExecuteOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling executeQuestionTestCase.');
        }

        if (requestParameters.questionTestCaseExecuteIn === null || requestParameters.questionTestCaseExecuteIn === undefined) {
            throw new runtime.RequiredError('questionTestCaseExecuteIn','Required parameter requestParameters.questionTestCaseExecuteIn was null or undefined when calling executeQuestionTestCase.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/manage/questions/{content_id}/test-cases/execution`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionTestCaseExecuteInToJSON(requestParameters.questionTestCaseExecuteIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionTestCaseExecuteOutFromJSON(jsonValue));
    }

    /**
     * 問題管理者が問題の検証用のためにテストケースを実行する - ジャッジシステムにリクエストを送信   - リクエストデータ     - pg_lang: リクエストボディ     - source_code: リクエストボディ     - JudgeType.VERIFICATION(問題検証)     - judge_code: QuestionVerificationResult(問題テストケース別検証結果).id     - gcs_file_paths: filename(ファイル名), url(ファイルURL)     - test_case_id_list     - original_case_list: 空のリスト - API実行時DB登録データ   - QuestionVerificationResult(問題テストケース別検証結果)     - question_id     - user_id     - pg_lang_id     - source_code     - total_test_case_count   - QuestionVerificationCaseResult(問題テストケース別検証結果)     - question_verification_result_id(問題検証結果ID)     - question_test_case_id(問題テストケースID) - 例外処理   - プログラミング言語が存在しない場合DataDoesNotExist   - コンテンツまたは問題が存在しない場合NotFound   - テストケース(サンプルケース含む)が存在しない場合NotFound
     * 検証用テストケース実行
     */
    async executeQuestionTestCase(requestParameters: ExecuteQuestionTestCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionTestCaseExecuteOut> {
        const response = await this.executeQuestionTestCaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * バグコード登録結果取得
     * バグコード登録結果取得
     */
    async getBugCodeRegistrationResultRaw(requestParameters: GetBugCodeRegistrationResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BugCodeRegistrationResultOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getBugCodeRegistrationResult.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/{content_id}/bug_code/result`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BugCodeRegistrationResultOutFromJSON(jsonValue));
    }

    /**
     * バグコード登録結果取得
     * バグコード登録結果取得
     */
    async getBugCodeRegistrationResult(requestParameters: GetBugCodeRegistrationResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BugCodeRegistrationResultOut> {
        const response = await this.getBugCodeRegistrationResultRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * \" コンテンツ作成者一覧取得 - 必要権限: [OWN_SESSION_VIEW] [ALL_EVENT_AND_SESSION_VIEW] - 並び順:ID降順 ログインユーザーの所属組織によって作成されたContent.created_byを一覧で取得する 取得条件： - Content_division＝ストック問題・第三者作成 - is_published=True - is_official=False -     学校ユーザの場合：         - is_shared_between_schools=Trueのレコードも含む
     * コンテンツ作成者一覧取得
     */
    async getContentCreatedByRaw(requestParameters: GetContentCreatedByRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ContentCreatedByOut>>> {
        const queryParameters: any = {};

        if (requestParameters.isGeneral !== undefined) {
            queryParameters['is_general'] = requestParameters.isGeneral;
        }

        if (requestParameters.isProQuestion !== undefined) {
            queryParameters['is_pro_question'] = requestParameters.isProQuestion;
        }

        if (requestParameters.isMaterial !== undefined) {
            queryParameters['is_material'] = requestParameters.isMaterial;
        }

        if (requestParameters.isTechthon !== undefined) {
            queryParameters['is_techthon'] = requestParameters.isTechthon;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/created_by`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ContentCreatedByOutFromJSON));
    }

    /**
     * \" コンテンツ作成者一覧取得 - 必要権限: [OWN_SESSION_VIEW] [ALL_EVENT_AND_SESSION_VIEW] - 並び順:ID降順 ログインユーザーの所属組織によって作成されたContent.created_byを一覧で取得する 取得条件： - Content_division＝ストック問題・第三者作成 - is_published=True - is_official=False -     学校ユーザの場合：         - is_shared_between_schools=Trueのレコードも含む
     * コンテンツ作成者一覧取得
     */
    async getContentCreatedBy(requestParameters: GetContentCreatedByRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ContentCreatedByOut>> {
        const response = await this.getContentCreatedByRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * コンテンツタグ一覧取得 - 必要権限: [OWN_SESSION_VIEW][OWN_EVENT_VIEW]     - 全てがFalseの時は全てのコンテンツタイプのものを取得     - is_general: コンテンツタイプが問題のものを取得     - is_pro_question: コンテンツタイプがPRO問題のものを取得     - is_material: コンテンツタイプが教材のものを取得     - is_techthon: コンテンツタイプがtechthonのものを取得
     * コンテンツタグ一覧取得
     */
    async getContentTagsRaw(requestParameters: GetContentTagsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ContentTagOut>>> {
        const queryParameters: any = {};

        if (requestParameters.isGeneral !== undefined) {
            queryParameters['is_general'] = requestParameters.isGeneral;
        }

        if (requestParameters.isProQuestion !== undefined) {
            queryParameters['is_pro_question'] = requestParameters.isProQuestion;
        }

        if (requestParameters.isMaterial !== undefined) {
            queryParameters['is_material'] = requestParameters.isMaterial;
        }

        if (requestParameters.isTechthon !== undefined) {
            queryParameters['is_techthon'] = requestParameters.isTechthon;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/tags`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ContentTagOutFromJSON));
    }

    /**
     * コンテンツタグ一覧取得 - 必要権限: [OWN_SESSION_VIEW][OWN_EVENT_VIEW]     - 全てがFalseの時は全てのコンテンツタイプのものを取得     - is_general: コンテンツタイプが問題のものを取得     - is_pro_question: コンテンツタイプがPRO問題のものを取得     - is_material: コンテンツタイプが教材のものを取得     - is_techthon: コンテンツタイプがtechthonのものを取得
     * コンテンツタグ一覧取得
     */
    async getContentTags(requestParameters: GetContentTagsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ContentTagOut>> {
        const response = await this.getContentTagsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題詳細取得 - 必要権限: [PROBLEM_VIEW]
     * 問題詳細取得
     */
    async getQuestionRaw(requestParameters: GetQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionDetailOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getQuestion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/{content_id}`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionDetailOutFromJSON(jsonValue));
    }

    /**
     * 問題詳細取得 - 必要権限: [PROBLEM_VIEW]
     * 問題詳細取得
     */
    async getQuestion(requestParameters: GetQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionDetailOut> {
        const response = await this.getQuestionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * イベント向け問題詳細取得 - 必要権限: [OWN_SESSION_VIEW][ALL_EVENT_AND_SESSION_EDIT] - 取得可能データ     - is_deleted=False     - 自組織作成または`is_shared_between_schools=True`     - is_published=True
     * イベント用問題詳細取得
     */
    async getQuestionForEventRaw(requestParameters: GetQuestionForEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionDetailOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getQuestionForEvent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/{content_id}/event`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionDetailOutFromJSON(jsonValue));
    }

    /**
     * イベント向け問題詳細取得 - 必要権限: [OWN_SESSION_VIEW][ALL_EVENT_AND_SESSION_EDIT] - 取得可能データ     - is_deleted=False     - 自組織作成または`is_shared_between_schools=True`     - is_published=True
     * イベント用問題詳細取得
     */
    async getQuestionForEvent(requestParameters: GetQuestionForEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionDetailOut> {
        const response = await this.getQuestionForEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題一覧取得 - 必要権限: [PROBLEM_VIEW] - 検索：ID/問題名/問題形式/コンテンツ区分/カテゴリ/難易度/問題タグ/検証済/公式・公開済み含む/で絞り込み - ページネーション: offset/limitの件数に従って取得 - order_byに従ってソート - 自組織で作成した問題のみ取得可能 - （学校ユーザーで実行時）他校が作成した問題は作成者・更新者欄に作成した学校名が表示される
     * 問題一覧取得
     */
    async getQuestionListRaw(requestParameters: GetQuestionListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionListOut>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.contentId !== undefined) {
            queryParameters['content_id'] = requestParameters.contentId;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.questionTypes) {
            queryParameters['question_types'] = requestParameters.questionTypes;
        }

        if (requestParameters.contentDivisions) {
            queryParameters['content_divisions'] = requestParameters.contentDivisions;
        }

        if (requestParameters.contentCategoryIds) {
            queryParameters['content_category_ids'] = requestParameters.contentCategoryIds;
        }

        if (requestParameters.difficulties) {
            queryParameters['difficulties'] = requestParameters.difficulties;
        }

        if (requestParameters.tags) {
            queryParameters['tags'] = requestParameters.tags;
        }

        if (requestParameters.isVerified !== undefined) {
            queryParameters['is_verified'] = requestParameters.isVerified;
        }

        if (requestParameters.isFavorite !== undefined) {
            queryParameters['is_favorite'] = requestParameters.isFavorite;
        }

        if (requestParameters.isOfficial !== undefined) {
            queryParameters['is_official'] = requestParameters.isOfficial;
        }

        if (requestParameters.isOriginalPrivate !== undefined) {
            queryParameters['is_original_private'] = requestParameters.isOriginalPrivate;
        }

        if (requestParameters.isOriginalOtherSchoolsPublic !== undefined) {
            queryParameters['is_original_other_schools_public'] = requestParameters.isOriginalOtherSchoolsPublic;
        }

        if (requestParameters.isStock !== undefined) {
            queryParameters['is_stock'] = requestParameters.isStock;
        }

        if (requestParameters.isSharedSchoolsTestcases !== undefined) {
            queryParameters['is_shared_schools_testcases'] = requestParameters.isSharedSchoolsTestcases;
        }

        if (requestParameters.isSharedSchoolsNoneTestcases !== undefined) {
            queryParameters['is_shared_schools_none_testcases'] = requestParameters.isSharedSchoolsNoneTestcases;
        }

        if (requestParameters.createdBy) {
            queryParameters['created_by'] = requestParameters.createdBy;
        }

        if (requestParameters.orderBy !== undefined) {
            queryParameters['order_by'] = requestParameters.orderBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionListOutFromJSON(jsonValue));
    }

    /**
     * 問題一覧取得 - 必要権限: [PROBLEM_VIEW] - 検索：ID/問題名/問題形式/コンテンツ区分/カテゴリ/難易度/問題タグ/検証済/公式・公開済み含む/で絞り込み - ページネーション: offset/limitの件数に従って取得 - order_byに従ってソート - 自組織で作成した問題のみ取得可能 - （学校ユーザーで実行時）他校が作成した問題は作成者・更新者欄に作成した学校名が表示される
     * 問題一覧取得
     */
    async getQuestionList(requestParameters: GetQuestionListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionListOut> {
        const response = await this.getQuestionListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * イベント向け問題一覧取得 - 必要権限: [OWN_SESSION_VIEW][OWN_EVENT_VIEW] - 検索：問題名/問題形式/コンテンツ区分/カテゴリ/難易度/問題タグで絞り込み - 取得可能条件     - is_deleted = False     - is_verified = True     - コンテンツ区分：ストック、第三者作成     - 作成者     - 学校ユーザー         - 問題作成組織：自校、444         - 問題作成者：公式(is_official)、共有コンテンツ(is_shared_between_schools)、自校     - 企業ユーザー         - 問題作成組織：自社、444         - 問題作成者：公式、自社     - 444スタッフ         - 問題作成組織：444         - 問題作成者：自組織作成の全ての問題 - 並び順:     - id降順 - 作成者のレスポンス値について     - 公式問題の場合 公式:TechFUL(固定値)で表示     - 上記以外         - 問題作成者をそのまま表示
     * イベント向け問題一覧取得
     */
    async getQuestionListForEventRaw(requestParameters: GetQuestionListForEventRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<QuestionListDetailOut>>> {
        const queryParameters: any = {};

        if (requestParameters.contentId !== undefined) {
            queryParameters['content_id'] = requestParameters.contentId;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.questionTypes) {
            queryParameters['question_types'] = requestParameters.questionTypes;
        }

        if (requestParameters.contentCategoryIds) {
            queryParameters['content_category_ids'] = requestParameters.contentCategoryIds;
        }

        if (requestParameters.difficulties) {
            queryParameters['difficulties'] = requestParameters.difficulties;
        }

        if (requestParameters.tags) {
            queryParameters['tags'] = requestParameters.tags;
        }

        if (requestParameters.isFavorite !== undefined) {
            queryParameters['is_favorite'] = requestParameters.isFavorite;
        }

        if (requestParameters.isOfficial !== undefined) {
            queryParameters['is_official'] = requestParameters.isOfficial;
        }

        if (requestParameters.isSharedBetweenSchools !== undefined) {
            queryParameters['is_shared_between_schools'] = requestParameters.isSharedBetweenSchools;
        }

        if (requestParameters.createdBy) {
            queryParameters['created_by'] = requestParameters.createdBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/event`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(QuestionListDetailOutFromJSON));
    }

    /**
     * イベント向け問題一覧取得 - 必要権限: [OWN_SESSION_VIEW][OWN_EVENT_VIEW] - 検索：問題名/問題形式/コンテンツ区分/カテゴリ/難易度/問題タグで絞り込み - 取得可能条件     - is_deleted = False     - is_verified = True     - コンテンツ区分：ストック、第三者作成     - 作成者     - 学校ユーザー         - 問題作成組織：自校、444         - 問題作成者：公式(is_official)、共有コンテンツ(is_shared_between_schools)、自校     - 企業ユーザー         - 問題作成組織：自社、444         - 問題作成者：公式、自社     - 444スタッフ         - 問題作成組織：444         - 問題作成者：自組織作成の全ての問題 - 並び順:     - id降順 - 作成者のレスポンス値について     - 公式問題の場合 公式:TechFUL(固定値)で表示     - 上記以外         - 問題作成者をそのまま表示
     * イベント向け問題一覧取得
     */
    async getQuestionListForEvent(requestParameters: GetQuestionListForEventRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<QuestionListDetailOut>> {
        const response = await this.getQuestionListForEventRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題管理者が問題の検証用のために実行した、テストケース実行結果を取得する - 必要権限: [PROBLEM_VIEW] - 並び順: order昇順 - 例外処理   - 問題が存在しない場合、NotFound   - 問題検証結果が存在しない場合、NotFound   - 問題テストケース別検証結果が存在しない場合、NotFound - 処理手順     - 該当QuestionVerificationResultを取得する     - 最後のポーリングの場合、かつ、全サンプルケースと全テストケースが取得できない場合、            QuestionVerificationResultのquestion_answer_resultをSERVER_ERRORに更新する     - 全部のケースが取得できた場合、結果を返す
     * 検証用テストケース実行結果取得
     */
    async getQuestionTestCaseExecutionResultsRaw(requestParameters: GetQuestionTestCaseExecutionResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionVerificationResultOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getQuestionTestCaseExecutionResults.');
        }

        if (requestParameters.questionVerificationResultId === null || requestParameters.questionVerificationResultId === undefined) {
            throw new runtime.RequiredError('questionVerificationResultId','Required parameter requestParameters.questionVerificationResultId was null or undefined when calling getQuestionTestCaseExecutionResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.isLastQuery !== undefined) {
            queryParameters['is_last_query'] = requestParameters.isLastQuery;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/{content_id}/test-cases/{question_verification_result_id}/execution-result`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))).replace(`{${"question_verification_result_id"}}`, encodeURIComponent(String(requestParameters.questionVerificationResultId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionVerificationResultOutFromJSON(jsonValue));
    }

    /**
     * 問題管理者が問題の検証用のために実行した、テストケース実行結果を取得する - 必要権限: [PROBLEM_VIEW] - 並び順: order昇順 - 例外処理   - 問題が存在しない場合、NotFound   - 問題検証結果が存在しない場合、NotFound   - 問題テストケース別検証結果が存在しない場合、NotFound - 処理手順     - 該当QuestionVerificationResultを取得する     - 最後のポーリングの場合、かつ、全サンプルケースと全テストケースが取得できない場合、            QuestionVerificationResultのquestion_answer_resultをSERVER_ERRORに更新する     - 全部のケースが取得できた場合、結果を返す
     * 検証用テストケース実行結果取得
     */
    async getQuestionTestCaseExecutionResults(requestParameters: GetQuestionTestCaseExecutionResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionVerificationResultOut> {
        const response = await this.getQuestionTestCaseExecutionResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題テストケース一覧取得 - 必要権限: [PROBLEM_VIEW] - content_id（Question）に紐づくテストケースを取得 - is_sample_case=Trueの場合サンプルケースのみ取得する - テストケースのファイルサイズが一定以上大きい場合     - stdin/stdoutを省略表示する     - is_omitted=Trueにして返却する
     * テストケース一覧取得
     */
    async getQuestionTestCasesRaw(requestParameters: GetQuestionTestCasesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<QuestionTestCasesListOut>>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getQuestionTestCases.');
        }

        const queryParameters: any = {};

        if (requestParameters.isSampleCase !== undefined) {
            queryParameters['is_sample_case'] = requestParameters.isSampleCase;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/{content_id}/test-cases/`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(QuestionTestCasesListOutFromJSON));
    }

    /**
     * 問題テストケース一覧取得 - 必要権限: [PROBLEM_VIEW] - content_id（Question）に紐づくテストケースを取得 - is_sample_case=Trueの場合サンプルケースのみ取得する - テストケースのファイルサイズが一定以上大きい場合     - stdin/stdoutを省略表示する     - is_omitted=Trueにして返却する
     * テストケース一覧取得
     */
    async getQuestionTestCases(requestParameters: GetQuestionTestCasesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<QuestionTestCasesListOut>> {
        const response = await this.getQuestionTestCasesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題検証履歴一覧取得 - 必要権限:[PROBLEM_VIEW] - other=True:他管理者の検証履歴を取得する
     * 問題検証履歴一覧取得
     */
    async getQuestionVerificationListRaw(requestParameters: GetQuestionVerificationListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<QuestionVerificationListOut>>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getQuestionVerificationList.');
        }

        const queryParameters: any = {};

        if (requestParameters.other !== undefined) {
            queryParameters['other'] = requestParameters.other;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/manage/questions/{content_id}/verification`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(QuestionVerificationListOutFromJSON));
    }

    /**
     * 問題検証履歴一覧取得 - 必要権限:[PROBLEM_VIEW] - other=True:他管理者の検証履歴を取得する
     * 問題検証履歴一覧取得
     */
    async getQuestionVerificationList(requestParameters: GetQuestionVerificationListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<QuestionVerificationListOut>> {
        const response = await this.getQuestionVerificationListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題を公開状態へ変更する - 必要権限：[PROBLEM_PUBLISH] - 問題IDをリストで受け取り、公開状態(is_published=True)へ変更する
     * 問題公開
     */
    async publishQuestionRaw(requestParameters: PublishQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.questionPublishIn === null || requestParameters.questionPublishIn === undefined) {
            throw new runtime.RequiredError('questionPublishIn','Required parameter requestParameters.questionPublishIn was null or undefined when calling publishQuestion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/manage/questions/publish`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.questionPublishIn.map(QuestionPublishInToJSON),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 問題を公開状態へ変更する - 必要権限：[PROBLEM_PUBLISH] - 問題IDをリストで受け取り、公開状態(is_published=True)へ変更する
     * 問題公開
     */
    async publishQuestion(requestParameters: PublishQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.publishQuestionRaw(requestParameters, initOverrides);
    }

    /**
     * バグコード登録 - ジャッジシステムにリクエストを送る - リクエストデータ     - pg_lang.lang_code     - source_code     - judge_type: JudgeType.TEMPLATE,     - judge_code: template.id,     - gcs_file_paths: list[str]     - sample_case_id_list: list[int] - API実行時登録データ     - source_code     - pg_lang_id     - question_id     - judge_status.WJ
     * バグコード登録
     */
    async registerBugCodeRaw(requestParameters: RegisterBugCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling registerBugCode.');
        }

        if (requestParameters.bugCodeRegisterIn === null || requestParameters.bugCodeRegisterIn === undefined) {
            throw new runtime.RequiredError('bugCodeRegisterIn','Required parameter requestParameters.bugCodeRegisterIn was null or undefined when calling registerBugCode.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/manage/questions/{content_id}/bug_code/register`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BugCodeRegisterInToJSON(requestParameters.bugCodeRegisterIn),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * バグコード登録 - ジャッジシステムにリクエストを送る - リクエストデータ     - pg_lang.lang_code     - source_code     - judge_type: JudgeType.TEMPLATE,     - judge_code: template.id,     - gcs_file_paths: list[str]     - sample_case_id_list: list[int] - API実行時登録データ     - source_code     - pg_lang_id     - question_id     - judge_status.WJ
     * バグコード登録
     */
    async registerBugCode(requestParameters: RegisterBugCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.registerBugCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題更新API - 必要権限：[PROBLEM_EDIT] - 更新条件：     - is_deleted=False     - 自組織が作成した問題のみ更新可能     - content_type=ContentType.GENERAL - updated_by: user.fullname
     * 問題更新
     */
    async updateQuestionRaw(requestParameters: UpdateQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionDetailOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling updateQuestion.');
        }

        if (requestParameters.questionUpdateIn === null || requestParameters.questionUpdateIn === undefined) {
            throw new runtime.RequiredError('questionUpdateIn','Required parameter requestParameters.questionUpdateIn was null or undefined when calling updateQuestion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/manage/questions/{content_id}`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionUpdateInToJSON(requestParameters.questionUpdateIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionDetailOutFromJSON(jsonValue));
    }

    /**
     * 問題更新API - 必要権限：[PROBLEM_EDIT] - 更新条件：     - is_deleted=False     - 自組織が作成した問題のみ更新可能     - content_type=ContentType.GENERAL - updated_by: user.fullname
     * 問題更新
     */
    async updateQuestion(requestParameters: UpdateQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionDetailOut> {
        const response = await this.updateQuestionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 英語問題文更新 - 必要権限: [PROBLEM_EDIT]
     * 英語問題文更新
     */
    async updateQuestionEnglishTextRaw(requestParameters: UpdateQuestionEnglishTextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling updateQuestionEnglishText.');
        }

        if (requestParameters.questionEnglishTextUpdateIn === null || requestParameters.questionEnglishTextUpdateIn === undefined) {
            throw new runtime.RequiredError('questionEnglishTextUpdateIn','Required parameter requestParameters.questionEnglishTextUpdateIn was null or undefined when calling updateQuestionEnglishText.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/manage/questions/{content_id}/english`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionEnglishTextUpdateInToJSON(requestParameters.questionEnglishTextUpdateIn),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 英語問題文更新 - 必要権限: [PROBLEM_EDIT]
     * 英語問題文更新
     */
    async updateQuestionEnglishText(requestParameters: UpdateQuestionEnglishTextRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateQuestionEnglishTextRaw(requestParameters, initOverrides);
    }

}
