/* tslint:disable */
/* eslint-disable */
/**
 * TechFUL API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiError,
  BugCodeOut,
  CodeSubmissionHistoryListOut,
  ExecuteQuestionTestCaseIn,
  ExecuteQuestionTestCaseOut,
  GeneralQuestionChallengeListOut,
  GeneralQuestionLearningListOut,
  GeneralQuestionPracticeListOut,
  GetQuestionSampleCaseResultsOut,
  GetTestCaseResultsOut,
  QuestionBlankExecuteIn,
  QuestionBlankExecuteOut,
  QuestionDetailOut,
  QuestionExecuteSampleCaseIn,
  QuestionExecuteSampleCaseOut,
  QuestionResultStatusNoFail,
  QuestionResultType,
  QuestionSelectionExecuteIn,
  QuestionSelectionExecuteOut,
  QuestionType,
  QuestionsSampleCaseOut,
  ValidationError,
} from '../models/index';
import {
    ApiErrorFromJSON,
    ApiErrorToJSON,
    BugCodeOutFromJSON,
    BugCodeOutToJSON,
    CodeSubmissionHistoryListOutFromJSON,
    CodeSubmissionHistoryListOutToJSON,
    ExecuteQuestionTestCaseInFromJSON,
    ExecuteQuestionTestCaseInToJSON,
    ExecuteQuestionTestCaseOutFromJSON,
    ExecuteQuestionTestCaseOutToJSON,
    GeneralQuestionChallengeListOutFromJSON,
    GeneralQuestionChallengeListOutToJSON,
    GeneralQuestionLearningListOutFromJSON,
    GeneralQuestionLearningListOutToJSON,
    GeneralQuestionPracticeListOutFromJSON,
    GeneralQuestionPracticeListOutToJSON,
    GetQuestionSampleCaseResultsOutFromJSON,
    GetQuestionSampleCaseResultsOutToJSON,
    GetTestCaseResultsOutFromJSON,
    GetTestCaseResultsOutToJSON,
    QuestionBlankExecuteInFromJSON,
    QuestionBlankExecuteInToJSON,
    QuestionBlankExecuteOutFromJSON,
    QuestionBlankExecuteOutToJSON,
    QuestionDetailOutFromJSON,
    QuestionDetailOutToJSON,
    QuestionExecuteSampleCaseInFromJSON,
    QuestionExecuteSampleCaseInToJSON,
    QuestionExecuteSampleCaseOutFromJSON,
    QuestionExecuteSampleCaseOutToJSON,
    QuestionResultStatusNoFailFromJSON,
    QuestionResultStatusNoFailToJSON,
    QuestionResultTypeFromJSON,
    QuestionResultTypeToJSON,
    QuestionSelectionExecuteInFromJSON,
    QuestionSelectionExecuteInToJSON,
    QuestionSelectionExecuteOutFromJSON,
    QuestionSelectionExecuteOutToJSON,
    QuestionTypeFromJSON,
    QuestionTypeToJSON,
    QuestionsSampleCaseOutFromJSON,
    QuestionsSampleCaseOutToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models/index';

export interface ExecuteGeneralQuestionBlankRequest {
    contentId: number;
    questionBlankExecuteIn: QuestionBlankExecuteIn;
}

export interface ExecuteGeneralQuestionSampleCaseRequest {
    contentId: number;
    questionExecuteSampleCaseIn: QuestionExecuteSampleCaseIn;
    questionResultType?: QuestionResultType;
}

export interface ExecuteGeneralQuestionSelectionRequest {
    contentId: number;
    questionSelectionExecuteIn: QuestionSelectionExecuteIn;
}

export interface ExecuteGeneralQuestionTestCaseRequest {
    contentId: number;
    executeQuestionTestCaseIn: ExecuteQuestionTestCaseIn;
    questionResultType?: QuestionResultType;
}

export interface GeneralGetQuestionsSampleCaseRequest {
    contentId: number;
}

export interface GetBugCodeRequest {
    contentId: number;
}

export interface GetGeneralCodeSubmissionHistoryListRequest {
    contentId: number;
}

export interface GetGeneralQuestionRequest {
    contentId: number;
    sessionId?: number;
}

export interface GetGeneralQuestionChallengeListRequest {
    contentCategoryIds?: Array<number>;
    contentTopicIds?: Array<number>;
    questionTypes?: Array<QuestionType>;
    difficulties?: Array<number>;
    questionResultStatuses?: Array<QuestionResultStatusNoFail>;
}

export interface GetGeneralQuestionLearningListRequest {
    topicId: number;
    questionLevel: number;
}

export interface GetGeneralQuestionPracticeListRequest {
    contentCategoryIds?: Array<number>;
    contentTopicIds?: Array<number>;
    questionTypes?: Array<QuestionType>;
    difficulties?: Array<number>;
}

export interface GetQuestionSampleCaseResultsRequest {
    contentId: number;
    testResultId: number;
    isLastQuery?: boolean;
}

export interface GetQuestionTestCaseResultsRequest {
    contentId: number;
    testResultId: number;
    isLastQuery?: boolean;
}

export interface StartAnsweringQuestionRequest {
    contentId: number;
    sessionId?: number;
}

export interface StartGeneralQuestionAnswerRequest {
    contentId: number;
}

/**
 * 
 */
export class GeneralQuestionsApi extends runtime.BaseAPI {

    /**
     * 一般空欄問題採点実行 - チャレンジ問題等に使用し、セッション問題には使用しない - 必要権限: [GENERAL_USER] - レスポンス:     - 採点結果とQuestionの解答と各空欄の採点結果 - 処理内容:     - 該当問題が存在しない場合エラー(NotFound)     - QuestionResultにレコードが存在しない場合エラー(QuestionAnswerNotStarted)     - 採点を実行         - 該当問題のQuestionBlankのanswerと一致しているか各解答をチェック         - 全問題一致しているなら正解、1問でも不一致なら不正解     - QuestionBlankResultにデータを作成         - question_result_id: QuestionResultのID         - is_correct: 上記の採点結果(True or False)         - score: 0         - is_used_for_result: 上記の採点結果(True or False)     - QuestionBlankEachResultに送られてきた選択肢毎のデータを作成         - question_blank_id: 該当問題の空欄ID         - question_blank_result_id: 上記で作成したQuestionBlankResultのID         - answer: 空欄IDに対応するリクエストで送られてきたユーザの解答テキスト         - is_correct: 対象空欄の採点結果(True or False)     - QuestionResultに結果を書き込む         - question_result_status: QuestionResultStatus.PASS or QuestionResultStatus.ANSWERING - 補足情報:     - 空欄問題に点数はつけないためスコアは0点とする(将来的に点数はつける予定)     - 空欄問題はJudgeシステムで採点は行わない
     * 一般空欄問題採点実行
     */
    async executeGeneralQuestionBlankRaw(requestParameters: ExecuteGeneralQuestionBlankRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionBlankExecuteOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling executeGeneralQuestionBlank.');
        }

        if (requestParameters.questionBlankExecuteIn === null || requestParameters.questionBlankExecuteIn === undefined) {
            throw new runtime.RequiredError('questionBlankExecuteIn','Required parameter requestParameters.questionBlankExecuteIn was null or undefined when calling executeGeneralQuestionBlank.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/general/questions/{content_id}/blank/execute`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionBlankExecuteInToJSON(requestParameters.questionBlankExecuteIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionBlankExecuteOutFromJSON(jsonValue));
    }

    /**
     * 一般空欄問題採点実行 - チャレンジ問題等に使用し、セッション問題には使用しない - 必要権限: [GENERAL_USER] - レスポンス:     - 採点結果とQuestionの解答と各空欄の採点結果 - 処理内容:     - 該当問題が存在しない場合エラー(NotFound)     - QuestionResultにレコードが存在しない場合エラー(QuestionAnswerNotStarted)     - 採点を実行         - 該当問題のQuestionBlankのanswerと一致しているか各解答をチェック         - 全問題一致しているなら正解、1問でも不一致なら不正解     - QuestionBlankResultにデータを作成         - question_result_id: QuestionResultのID         - is_correct: 上記の採点結果(True or False)         - score: 0         - is_used_for_result: 上記の採点結果(True or False)     - QuestionBlankEachResultに送られてきた選択肢毎のデータを作成         - question_blank_id: 該当問題の空欄ID         - question_blank_result_id: 上記で作成したQuestionBlankResultのID         - answer: 空欄IDに対応するリクエストで送られてきたユーザの解答テキスト         - is_correct: 対象空欄の採点結果(True or False)     - QuestionResultに結果を書き込む         - question_result_status: QuestionResultStatus.PASS or QuestionResultStatus.ANSWERING - 補足情報:     - 空欄問題に点数はつけないためスコアは0点とする(将来的に点数はつける予定)     - 空欄問題はJudgeシステムで採点は行わない
     * 一般空欄問題採点実行
     */
    async executeGeneralQuestionBlank(requestParameters: ExecuteGeneralQuestionBlankRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionBlankExecuteOut> {
        const response = await this.executeGeneralQuestionBlankRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 一般問題サンプルケース実行 - チャレンジ問題等に使用し、セッション問題には使用しない - 必要権限: [GENERAL_USER] - 解答開始していない場合はエラー     - QuestionResultから[ユーザーID、問題ID、解答種別:チャレンジ]に該当するデータが取得できない - QuestionTestResultにデータを作成     - source_code: リクエストの値     - pg_lang_id: リクエストの値     - question_answer_result: QuestionAnswerResult.SCORING     - is_used_for_result: False     - total_test_case_count: 問題に紐づくサンプルケース数     - is_sample_case: True - QuestionTestCaseResultにサンプルケース毎のデータを作成     - question_test_result_id: 上記で作成したQuestionTestResultのID     - question_test_case_id: 対応するサンプルケースのID     - judge_status: JudgeStatus.WJ - Judgeシステムの採点API実行
     * 一般問題サンプルケース実行
     */
    async executeGeneralQuestionSampleCaseRaw(requestParameters: ExecuteGeneralQuestionSampleCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionExecuteSampleCaseOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling executeGeneralQuestionSampleCase.');
        }

        if (requestParameters.questionExecuteSampleCaseIn === null || requestParameters.questionExecuteSampleCaseIn === undefined) {
            throw new runtime.RequiredError('questionExecuteSampleCaseIn','Required parameter requestParameters.questionExecuteSampleCaseIn was null or undefined when calling executeGeneralQuestionSampleCase.');
        }

        const queryParameters: any = {};

        if (requestParameters.questionResultType !== undefined) {
            queryParameters['question_result_type'] = requestParameters.questionResultType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/general/questions/{content_id}/sample-cases/execute`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionExecuteSampleCaseInToJSON(requestParameters.questionExecuteSampleCaseIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionExecuteSampleCaseOutFromJSON(jsonValue));
    }

    /**
     * 一般問題サンプルケース実行 - チャレンジ問題等に使用し、セッション問題には使用しない - 必要権限: [GENERAL_USER] - 解答開始していない場合はエラー     - QuestionResultから[ユーザーID、問題ID、解答種別:チャレンジ]に該当するデータが取得できない - QuestionTestResultにデータを作成     - source_code: リクエストの値     - pg_lang_id: リクエストの値     - question_answer_result: QuestionAnswerResult.SCORING     - is_used_for_result: False     - total_test_case_count: 問題に紐づくサンプルケース数     - is_sample_case: True - QuestionTestCaseResultにサンプルケース毎のデータを作成     - question_test_result_id: 上記で作成したQuestionTestResultのID     - question_test_case_id: 対応するサンプルケースのID     - judge_status: JudgeStatus.WJ - Judgeシステムの採点API実行
     * 一般問題サンプルケース実行
     */
    async executeGeneralQuestionSampleCase(requestParameters: ExecuteGeneralQuestionSampleCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionExecuteSampleCaseOut> {
        const response = await this.executeGeneralQuestionSampleCaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 一般選択式問題採点実行 - チャレンジ問題等に使用し、セッション問題には使用しない - 必要権限: [GENERAL_USER] - レスポンス:     - 採点結果とQuestionの解答 - 処理内容:     - 該当問題が存在しない場合エラー(NotFound)     - QuestionResultにレコードが存在しない場合エラー(QuestionAnswerNotStarted)     - 採点を実行         - ユーザが選択したorderの中で該当問題のQuestionChoiceのis_correct=Falseがある場合不正解         - そうでなければ正解     - QuestionChoiceResultにデータを作成         - question_result_id: QuestionResultのID         - score: 0         - is_correct: 上記の採点結果(True or False)         - is_used_for_result: 上記の採点結果(True or False)     - QuestionChoiceResultRelationに送られてきた選択肢毎のデータを作成         - question_choice_id: ユーザが選択した選択肢のID         - question_choice_result_id: 上記で作成したQuestionChoiceResultのID - 補足情報:     - 選択式問題に点数はつけないためスコアは0点とする(将来的に点数はつける予定)     - 選択式問題はJudgeシステムで採点は行わない
     * 一般選択式問題採点実行
     */
    async executeGeneralQuestionSelectionRaw(requestParameters: ExecuteGeneralQuestionSelectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionSelectionExecuteOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling executeGeneralQuestionSelection.');
        }

        if (requestParameters.questionSelectionExecuteIn === null || requestParameters.questionSelectionExecuteIn === undefined) {
            throw new runtime.RequiredError('questionSelectionExecuteIn','Required parameter requestParameters.questionSelectionExecuteIn was null or undefined when calling executeGeneralQuestionSelection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/general/questions/{content_id}/selection/execute`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionSelectionExecuteInToJSON(requestParameters.questionSelectionExecuteIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionSelectionExecuteOutFromJSON(jsonValue));
    }

    /**
     * 一般選択式問題採点実行 - チャレンジ問題等に使用し、セッション問題には使用しない - 必要権限: [GENERAL_USER] - レスポンス:     - 採点結果とQuestionの解答 - 処理内容:     - 該当問題が存在しない場合エラー(NotFound)     - QuestionResultにレコードが存在しない場合エラー(QuestionAnswerNotStarted)     - 採点を実行         - ユーザが選択したorderの中で該当問題のQuestionChoiceのis_correct=Falseがある場合不正解         - そうでなければ正解     - QuestionChoiceResultにデータを作成         - question_result_id: QuestionResultのID         - score: 0         - is_correct: 上記の採点結果(True or False)         - is_used_for_result: 上記の採点結果(True or False)     - QuestionChoiceResultRelationに送られてきた選択肢毎のデータを作成         - question_choice_id: ユーザが選択した選択肢のID         - question_choice_result_id: 上記で作成したQuestionChoiceResultのID - 補足情報:     - 選択式問題に点数はつけないためスコアは0点とする(将来的に点数はつける予定)     - 選択式問題はJudgeシステムで採点は行わない
     * 一般選択式問題採点実行
     */
    async executeGeneralQuestionSelection(requestParameters: ExecuteGeneralQuestionSelectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionSelectionExecuteOut> {
        const response = await this.executeGeneralQuestionSelectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 一般問題テストケース実行 - チャレンジ問題等に使用し、セッション問題には使用しない - 必要権限: [GENERAL_USER] (SKILL_CHECK_USERはこのAPIを使用しない、SKILL_CHECK_USERはセッション問題のみ) - 例外処理     - 該当問題が存在しない場合はエラー(NotFound)         - Content.is_deleted = False         - Question.content_id = content_id         - Question.question_type in [QuestionType.CORDING, QuestionType.FILLING, QuestionType.BUG]     - 該当言語が存在しない場合はエラー(DataDoesNotExist)     - QuestionResultから該当するデータが取得できない場合はエラー(QuestionAnswerNotStarted)         - QuestionResult.user_id = user.id         - QuestionResult.question_id = Question.id         - QuestionResult.session_id is None         - QuestionResult.old_session_id is None         - QuestionResult.question_result_type in                 [QuestionResultType.CHALLENGE, QuestionResultType.PRACTICE, QuestionResultType.LEANING] - 処理手順     - QuestionTestResultにデータを作成         - source_code: リクエストの値         - pg_lang_id: リクエストの値         - question_answer_result: QuestionAnswerResult.SCORING         - is_sample_case: False     - QuestionTestCaseResultにテストケース毎のデータを作成         - question_test_result_id: 上記で作成したQuestionTestResultのID         - question_test_case_id: 対応するテストケースのID         - judge_status: JudgeStatus.WJ     - Judgeシステムの採点API実行
     * 一般問題テストケース実行
     */
    async executeGeneralQuestionTestCaseRaw(requestParameters: ExecuteGeneralQuestionTestCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecuteQuestionTestCaseOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling executeGeneralQuestionTestCase.');
        }

        if (requestParameters.executeQuestionTestCaseIn === null || requestParameters.executeQuestionTestCaseIn === undefined) {
            throw new runtime.RequiredError('executeQuestionTestCaseIn','Required parameter requestParameters.executeQuestionTestCaseIn was null or undefined when calling executeGeneralQuestionTestCase.');
        }

        const queryParameters: any = {};

        if (requestParameters.questionResultType !== undefined) {
            queryParameters['question_result_type'] = requestParameters.questionResultType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/general/questions/{content_id}/test-cases/execute`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExecuteQuestionTestCaseInToJSON(requestParameters.executeQuestionTestCaseIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecuteQuestionTestCaseOutFromJSON(jsonValue));
    }

    /**
     * 一般問題テストケース実行 - チャレンジ問題等に使用し、セッション問題には使用しない - 必要権限: [GENERAL_USER] (SKILL_CHECK_USERはこのAPIを使用しない、SKILL_CHECK_USERはセッション問題のみ) - 例外処理     - 該当問題が存在しない場合はエラー(NotFound)         - Content.is_deleted = False         - Question.content_id = content_id         - Question.question_type in [QuestionType.CORDING, QuestionType.FILLING, QuestionType.BUG]     - 該当言語が存在しない場合はエラー(DataDoesNotExist)     - QuestionResultから該当するデータが取得できない場合はエラー(QuestionAnswerNotStarted)         - QuestionResult.user_id = user.id         - QuestionResult.question_id = Question.id         - QuestionResult.session_id is None         - QuestionResult.old_session_id is None         - QuestionResult.question_result_type in                 [QuestionResultType.CHALLENGE, QuestionResultType.PRACTICE, QuestionResultType.LEANING] - 処理手順     - QuestionTestResultにデータを作成         - source_code: リクエストの値         - pg_lang_id: リクエストの値         - question_answer_result: QuestionAnswerResult.SCORING         - is_sample_case: False     - QuestionTestCaseResultにテストケース毎のデータを作成         - question_test_result_id: 上記で作成したQuestionTestResultのID         - question_test_case_id: 対応するテストケースのID         - judge_status: JudgeStatus.WJ     - Judgeシステムの採点API実行
     * 一般問題テストケース実行
     */
    async executeGeneralQuestionTestCase(requestParameters: ExecuteGeneralQuestionTestCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecuteQuestionTestCaseOut> {
        const response = await this.executeGeneralQuestionTestCaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題サンプルケース一覧取得 - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理:     - 該当問題が存在しない場合: NotFound - データ取得可能条件:     - Question.content_id = content_id     - QuestionTestCase.is_sample_case = True - レスポンス補足:     - QuestionTestCase.is_omitted がTrueの場合、shorten_stdin、shorten_stdoutを返す
     * セッション問題サンプルケース一覧取得
     */
    async generalGetQuestionsSampleCaseRaw(requestParameters: GeneralGetQuestionsSampleCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<QuestionsSampleCaseOut>>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling generalGetQuestionsSampleCase.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/{content_id}/sample-cases`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(QuestionsSampleCaseOutFromJSON));
    }

    /**
     * 問題サンプルケース一覧取得 - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理:     - 該当問題が存在しない場合: NotFound - データ取得可能条件:     - Question.content_id = content_id     - QuestionTestCase.is_sample_case = True - レスポンス補足:     - QuestionTestCase.is_omitted がTrueの場合、shorten_stdin、shorten_stdoutを返す
     * セッション問題サンプルケース一覧取得
     */
    async generalGetQuestionsSampleCase(requestParameters: GeneralGetQuestionsSampleCaseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<QuestionsSampleCaseOut>> {
        const response = await this.generalGetQuestionsSampleCaseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 一般バグコード取得 - バグコードが未登録の場合はNoneを返す - レスポンス     - pg_lang_id     - source_code     - name     - monaco_name
     * バグコード取得
     */
    async getBugCodeRaw(requestParameters: GetBugCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BugCodeOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getBugCode.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/{content_id}/bug_code`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BugCodeOutFromJSON(jsonValue));
    }

    /**
     * 一般バグコード取得 - バグコードが未登録の場合はNoneを返す - レスポンス     - pg_lang_id     - source_code     - name     - monaco_name
     * バグコード取得
     */
    async getBugCode(requestParameters: GetBugCodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BugCodeOut> {
        const response = await this.getBugCodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 提出履歴取得 - 必要権限: [GENERAL_USER] - 例外処理:     - 該当問題が存在しない場合: NotFound - データ取得可能条件:     - Question         - Content.is_deleted = False         - Content.content_type = ContentType.QUESTION         - Question.content_id = content_id     - QuestionTestResult         - question_answer_result not in [QuestionAnswerResult.SCORING, QuestionAnswerResult.SERVER_ERROR] - 処理手順     - 問題を特定     - question_idとuser.idでQuestionResultsを取得(全QuestionResultTypeの問題が対象)     - QuestionResult毎にquestion_test_resultsを取得(採点中とサーバーエラー以外) - 補足     - セッション問題での回答は含まれない     - 回答時間降順に並ぶ     - stdin, stdout表示条件(or)         - 「解答者にテストケースを公開フラグがTrue」         - 「プラクティス問題」かつ「問題の公開フラグがTrue」         - 「ラーニング問題」かつ「問題の公開フラグがTrue」
     * 提出履歴取得
     */
    async getGeneralCodeSubmissionHistoryListRaw(requestParameters: GetGeneralCodeSubmissionHistoryListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CodeSubmissionHistoryListOut>>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getGeneralCodeSubmissionHistoryList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/{content_id}/test-results`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CodeSubmissionHistoryListOutFromJSON));
    }

    /**
     * 提出履歴取得 - 必要権限: [GENERAL_USER] - 例外処理:     - 該当問題が存在しない場合: NotFound - データ取得可能条件:     - Question         - Content.is_deleted = False         - Content.content_type = ContentType.QUESTION         - Question.content_id = content_id     - QuestionTestResult         - question_answer_result not in [QuestionAnswerResult.SCORING, QuestionAnswerResult.SERVER_ERROR] - 処理手順     - 問題を特定     - question_idとuser.idでQuestionResultsを取得(全QuestionResultTypeの問題が対象)     - QuestionResult毎にquestion_test_resultsを取得(採点中とサーバーエラー以外) - 補足     - セッション問題での回答は含まれない     - 回答時間降順に並ぶ     - stdin, stdout表示条件(or)         - 「解答者にテストケースを公開フラグがTrue」         - 「プラクティス問題」かつ「問題の公開フラグがTrue」         - 「ラーニング問題」かつ「問題の公開フラグがTrue」
     * 提出履歴取得
     */
    async getGeneralCodeSubmissionHistoryList(requestParameters: GetGeneralCodeSubmissionHistoryListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CodeSubmissionHistoryListOut>> {
        const response = await this.getGeneralCodeSubmissionHistoryListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題詳細取得(通常問題用・セッション問題用) - 必要権限: [Pm.GENERAL_USER] [SKILL_CHECK_USER] - 実行条件:     - Content.is_deleted = False     - Content.is_published=True         - パラメーターにsession_idがある場合　Content.is_published=Falseも含む     - Content.content_type = ContentType.General (一般問題)     - セッション問題の場合:         - 既に問題解答開始しているか(user_id,session_idに紐づくQuestionResultレコードがあるか)チェック         - Queryパラメータ(session_id)を入力すること         - SessionUserであること         - Event.is_public = True         - Event.is_deleted = False         - Session.is_deleted = False         - SessionContentに含まれているもの - Response:     - NotFound:         - 削除済み問題・非公開の問題         - セッション問題ではない非公開の問題         - 削除済みセッション・非公開セッションの問題         - セッション参加者ではない一般ユーザーがセッション問題を閲覧する
     * 一般ユーザー用問題詳細取得
     */
    async getGeneralQuestionRaw(requestParameters: GetGeneralQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionDetailOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getGeneralQuestion.');
        }

        const queryParameters: any = {};

        if (requestParameters.sessionId !== undefined) {
            queryParameters['session_id'] = requestParameters.sessionId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/{content_id}`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionDetailOutFromJSON(jsonValue));
    }

    /**
     * 問題詳細取得(通常問題用・セッション問題用) - 必要権限: [Pm.GENERAL_USER] [SKILL_CHECK_USER] - 実行条件:     - Content.is_deleted = False     - Content.is_published=True         - パラメーターにsession_idがある場合　Content.is_published=Falseも含む     - Content.content_type = ContentType.General (一般問題)     - セッション問題の場合:         - 既に問題解答開始しているか(user_id,session_idに紐づくQuestionResultレコードがあるか)チェック         - Queryパラメータ(session_id)を入力すること         - SessionUserであること         - Event.is_public = True         - Event.is_deleted = False         - Session.is_deleted = False         - SessionContentに含まれているもの - Response:     - NotFound:         - 削除済み問題・非公開の問題         - セッション問題ではない非公開の問題         - 削除済みセッション・非公開セッションの問題         - セッション参加者ではない一般ユーザーがセッション問題を閲覧する
     * 一般ユーザー用問題詳細取得
     */
    async getGeneralQuestion(requestParameters: GetGeneralQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionDetailOut> {
        const response = await this.getGeneralQuestionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 一般チャレンジ問題一覧を取得 - 必要権限: [GENERAL_USER] - 並び順: difficulty, id 昇順 - 取得条件:     - content_type: GENERAL     - content_division: CHALLENGE     - is_deleted = False     - is_published = True     - is_official = True - レスポンスデータ補足情報     - challenger_count: 問題解答成績をカウント、問題に対応し問題解答種別がCHALLENGEのものをカウント     - passed_count: 問題解答成績をカウント、問題に対応し問題解答種別がCHALLENGEで解答状況が合格のものをカウント     - question_result_status: ログインユーザーの解答状況
     * 一般チャレンジ問題一覧取得
     */
    async getGeneralQuestionChallengeListRaw(requestParameters: GetGeneralQuestionChallengeListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GeneralQuestionChallengeListOut>>> {
        const queryParameters: any = {};

        if (requestParameters.contentCategoryIds) {
            queryParameters['content_category_ids'] = requestParameters.contentCategoryIds;
        }

        if (requestParameters.contentTopicIds) {
            queryParameters['content_topic_ids'] = requestParameters.contentTopicIds;
        }

        if (requestParameters.questionTypes) {
            queryParameters['question_types'] = requestParameters.questionTypes;
        }

        if (requestParameters.difficulties) {
            queryParameters['difficulties'] = requestParameters.difficulties;
        }

        if (requestParameters.questionResultStatuses) {
            queryParameters['question_result_statuses'] = requestParameters.questionResultStatuses;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/challenge`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GeneralQuestionChallengeListOutFromJSON));
    }

    /**
     * 一般チャレンジ問題一覧を取得 - 必要権限: [GENERAL_USER] - 並び順: difficulty, id 昇順 - 取得条件:     - content_type: GENERAL     - content_division: CHALLENGE     - is_deleted = False     - is_published = True     - is_official = True - レスポンスデータ補足情報     - challenger_count: 問題解答成績をカウント、問題に対応し問題解答種別がCHALLENGEのものをカウント     - passed_count: 問題解答成績をカウント、問題に対応し問題解答種別がCHALLENGEで解答状況が合格のものをカウント     - question_result_status: ログインユーザーの解答状況
     * 一般チャレンジ問題一覧取得
     */
    async getGeneralQuestionChallengeList(requestParameters: GetGeneralQuestionChallengeListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GeneralQuestionChallengeListOut>> {
        const response = await this.getGeneralQuestionChallengeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 一般ラーニング問題一覧を取得 - 必要権限: [GENERAL_USER] - 並び順: difficulty, id 昇順 - 取得条件:     - Category.name = プログラミング基礎     - Content.content_type: GENERAL     - Content.content_division: LEARNING     - Content.is_deleted = False     - Content.is_published = True     - Content.is_official = True - 例外     - topicが存在しなければ NotFound     - question_level が 1,2,3 のいずれかに該当しなければ NotFound
     * 一般ラーニング問題一覧取得
     */
    async getGeneralQuestionLearningListRaw(requestParameters: GetGeneralQuestionLearningListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GeneralQuestionLearningListOut>> {
        if (requestParameters.topicId === null || requestParameters.topicId === undefined) {
            throw new runtime.RequiredError('topicId','Required parameter requestParameters.topicId was null or undefined when calling getGeneralQuestionLearningList.');
        }

        if (requestParameters.questionLevel === null || requestParameters.questionLevel === undefined) {
            throw new runtime.RequiredError('questionLevel','Required parameter requestParameters.questionLevel was null or undefined when calling getGeneralQuestionLearningList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/practice/{topic_id}/{question_level}`.replace(`{${"topic_id"}}`, encodeURIComponent(String(requestParameters.topicId))).replace(`{${"question_level"}}`, encodeURIComponent(String(requestParameters.questionLevel))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GeneralQuestionLearningListOutFromJSON(jsonValue));
    }

    /**
     * 一般ラーニング問題一覧を取得 - 必要権限: [GENERAL_USER] - 並び順: difficulty, id 昇順 - 取得条件:     - Category.name = プログラミング基礎     - Content.content_type: GENERAL     - Content.content_division: LEARNING     - Content.is_deleted = False     - Content.is_published = True     - Content.is_official = True - 例外     - topicが存在しなければ NotFound     - question_level が 1,2,3 のいずれかに該当しなければ NotFound
     * 一般ラーニング問題一覧取得
     */
    async getGeneralQuestionLearningList(requestParameters: GetGeneralQuestionLearningListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GeneralQuestionLearningListOut> {
        const response = await this.getGeneralQuestionLearningListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 一般プラクティス問題一覧を取得 - 必要権限: [GENERAL_USER] - 並び順: difficulty, id 昇順 - 取得条件:     - content_type: GENERAL     - content_division: PRACTICE     - is_deleted = False     - is_published = True     - is_official = True
     * 一般プラクティス問題一覧取得
     */
    async getGeneralQuestionPracticeListRaw(requestParameters: GetGeneralQuestionPracticeListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GeneralQuestionPracticeListOut>>> {
        const queryParameters: any = {};

        if (requestParameters.contentCategoryIds) {
            queryParameters['content_category_ids'] = requestParameters.contentCategoryIds;
        }

        if (requestParameters.contentTopicIds) {
            queryParameters['content_topic_ids'] = requestParameters.contentTopicIds;
        }

        if (requestParameters.questionTypes) {
            queryParameters['question_types'] = requestParameters.questionTypes;
        }

        if (requestParameters.difficulties) {
            queryParameters['difficulties'] = requestParameters.difficulties;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/practice`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GeneralQuestionPracticeListOutFromJSON));
    }

    /**
     * 一般プラクティス問題一覧を取得 - 必要権限: [GENERAL_USER] - 並び順: difficulty, id 昇順 - 取得条件:     - content_type: GENERAL     - content_division: PRACTICE     - is_deleted = False     - is_published = True     - is_official = True
     * 一般プラクティス問題一覧取得
     */
    async getGeneralQuestionPracticeList(requestParameters: GetGeneralQuestionPracticeListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GeneralQuestionPracticeListOut>> {
        const response = await this.getGeneralQuestionPracticeListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題サンプルケース結果取得  - 必要権限: [GENERAL_USER] - 例外処理:     - 該当問題が存在しない場合: NotFound     - 該当QuestionTestResultが存在しない場合: NotFound     - QuestionTestResult.is_sample_caseがFalseの場合: NotFound - 並び順: QuestionTestCase.order昇順 - 処理手順     - 該当QuestionTestResultを取得する     - 最後のポーリングである場合、もし全部のケースが取得できなければ、サーバーエラーと判定し、            QuestionTestResultのquestion_answer_resultをSERVER_ERRORに更新する     - 取得できたケースを返す(test_case: test_case_id昇順, original_case: order昇順) - 備考:     - 一旦ポーリングの最大回数を超えてサーバーエラーに判定されたら、QuestionTestResult.question_answer_resultは変えないようにする     (\"app/services/judge_result/judge_result_question.py\"を修正する必要があるかもしれません)
     * 問題サンプルケース結果取得
     */
    async getQuestionSampleCaseResultsRaw(requestParameters: GetQuestionSampleCaseResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetQuestionSampleCaseResultsOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getQuestionSampleCaseResults.');
        }

        if (requestParameters.testResultId === null || requestParameters.testResultId === undefined) {
            throw new runtime.RequiredError('testResultId','Required parameter requestParameters.testResultId was null or undefined when calling getQuestionSampleCaseResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.isLastQuery !== undefined) {
            queryParameters['is_last_query'] = requestParameters.isLastQuery;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/{content_id}/test-results/{test_result_id}/sample-case`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))).replace(`{${"test_result_id"}}`, encodeURIComponent(String(requestParameters.testResultId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetQuestionSampleCaseResultsOutFromJSON(jsonValue));
    }

    /**
     * 問題サンプルケース結果取得  - 必要権限: [GENERAL_USER] - 例外処理:     - 該当問題が存在しない場合: NotFound     - 該当QuestionTestResultが存在しない場合: NotFound     - QuestionTestResult.is_sample_caseがFalseの場合: NotFound - 並び順: QuestionTestCase.order昇順 - 処理手順     - 該当QuestionTestResultを取得する     - 最後のポーリングである場合、もし全部のケースが取得できなければ、サーバーエラーと判定し、            QuestionTestResultのquestion_answer_resultをSERVER_ERRORに更新する     - 取得できたケースを返す(test_case: test_case_id昇順, original_case: order昇順) - 備考:     - 一旦ポーリングの最大回数を超えてサーバーエラーに判定されたら、QuestionTestResult.question_answer_resultは変えないようにする     (\"app/services/judge_result/judge_result_question.py\"を修正する必要があるかもしれません)
     * 問題サンプルケース結果取得
     */
    async getQuestionSampleCaseResults(requestParameters: GetQuestionSampleCaseResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetQuestionSampleCaseResultsOut> {
        const response = await this.getQuestionSampleCaseResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題テストケース結果取得 - 必要権限: [GENERAL_USER] - 例外処理:     - 該当問題が存在しない場合: NotFound     - 該当QuestionTestResultが存在しない場合: NotFound     - QuestionTestResult.is_sample_caseがFalseの場合: NotFound - 並び順: QuestionTestCase.order昇順 - 処理手順     - 該当QuestionTestResultを取得する     - 最後のポーリングである場合、もし全部のケースが取得できなければ、サーバーエラーと判定し、            QuestionTestResultのquestion_answer_resultをSERVER_ERRORに更新する     - 取得できたケースと集計結果を返す     - チャレンジ問題かつサーバーエラーではない場合、おすすめ問題も返す。 - 備考:     - 一旦ポーリングの最大回数を超えてサーバーエラーに判定されたら、QuestionTestResultのquestion_answer_resultは変えないようにする     (\"app/services/judge_result/judge_result_question.py\"を修正する必要があるかもしれません)
     * 問題テストケース結果取得
     */
    async getQuestionTestCaseResultsRaw(requestParameters: GetQuestionTestCaseResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTestCaseResultsOut>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getQuestionTestCaseResults.');
        }

        if (requestParameters.testResultId === null || requestParameters.testResultId === undefined) {
            throw new runtime.RequiredError('testResultId','Required parameter requestParameters.testResultId was null or undefined when calling getQuestionTestCaseResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.isLastQuery !== undefined) {
            queryParameters['is_last_query'] = requestParameters.isLastQuery;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/{content_id}/test-results/{test_result_id}/test-case`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))).replace(`{${"test_result_id"}}`, encodeURIComponent(String(requestParameters.testResultId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTestCaseResultsOutFromJSON(jsonValue));
    }

    /**
     * 問題テストケース結果取得 - 必要権限: [GENERAL_USER] - 例外処理:     - 該当問題が存在しない場合: NotFound     - 該当QuestionTestResultが存在しない場合: NotFound     - QuestionTestResult.is_sample_caseがFalseの場合: NotFound - 並び順: QuestionTestCase.order昇順 - 処理手順     - 該当QuestionTestResultを取得する     - 最後のポーリングである場合、もし全部のケースが取得できなければ、サーバーエラーと判定し、            QuestionTestResultのquestion_answer_resultをSERVER_ERRORに更新する     - 取得できたケースと集計結果を返す     - チャレンジ問題かつサーバーエラーではない場合、おすすめ問題も返す。 - 備考:     - 一旦ポーリングの最大回数を超えてサーバーエラーに判定されたら、QuestionTestResultのquestion_answer_resultは変えないようにする     (\"app/services/judge_result/judge_result_question.py\"を修正する必要があるかもしれません)
     * 問題テストケース結果取得
     */
    async getQuestionTestCaseResults(requestParameters: GetQuestionTestCaseResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTestCaseResultsOut> {
        const response = await this.getQuestionTestCaseResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題回答開始(通常問題・セッション問題) - 必要権限: [GENERAL_USER][SKILL_CHECK_USER] - 通常問題の場合     - 問題解答種別(QuestionResultType)         - チャンレンジ(QuestionResultType.CHALLENGE)         - プラクティス(QuestionResultType.PRACTICE)         - ラーニング・それ以外(QuestionResultType.LEARNING) - セッション問題の場合     - 問題解答種別(QuestionResultType)         - セッション(QuestionResultType.SESSION)
     * 問題回答開始(通常問題・セッション問題)
     */
    async startAnsweringQuestionRaw(requestParameters: StartAnsweringQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling startAnsweringQuestion.');
        }

        const queryParameters: any = {};

        if (requestParameters.sessionId !== undefined) {
            queryParameters['session_id'] = requestParameters.sessionId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/{content_id}/start`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 問題回答開始(通常問題・セッション問題) - 必要権限: [GENERAL_USER][SKILL_CHECK_USER] - 通常問題の場合     - 問題解答種別(QuestionResultType)         - チャンレンジ(QuestionResultType.CHALLENGE)         - プラクティス(QuestionResultType.PRACTICE)         - ラーニング・それ以外(QuestionResultType.LEARNING) - セッション問題の場合     - 問題解答種別(QuestionResultType)         - セッション(QuestionResultType.SESSION)
     * 問題回答開始(通常問題・セッション問題)
     */
    async startAnsweringQuestion(requestParameters: StartAnsweringQuestionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.startAnsweringQuestionRaw(requestParameters, initOverrides);
    }

    /**
     * 問題解答開始(チャレンジ問題で使用) - 必要権限: [GENERAL_USER] - QuestionResultにデータを作成する     - ユニーク項目: 以下のデータが存在する場合はスキップ         - question_id: content_idからquestionを取得し設定         - user_id: ログインユーザーのuser_id         - question_result_type: CHALLENGE     - question_result_status: ANSWERING
     * 問題解答開始
     */
    async startGeneralQuestionAnswerRaw(requestParameters: StartGeneralQuestionAnswerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling startGeneralQuestionAnswer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/questions/{content_id}/answer-start`.replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 問題解答開始(チャレンジ問題で使用) - 必要権限: [GENERAL_USER] - QuestionResultにデータを作成する     - ユニーク項目: 以下のデータが存在する場合はスキップ         - question_id: content_idからquestionを取得し設定         - user_id: ログインユーザーのuser_id         - question_result_type: CHALLENGE     - question_result_status: ANSWERING
     * 問題解答開始
     */
    async startGeneralQuestionAnswer(requestParameters: StartGeneralQuestionAnswerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.startGeneralQuestionAnswerRaw(requestParameters, initOverrides);
    }

}
