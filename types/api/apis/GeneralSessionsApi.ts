/* tslint:disable */
/* eslint-disable */
/**
 * TechFUL API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiError,
  AppSchemasGeneralSessionsGeneralSessionContentListOutSessionContentListOut,
  CertificateExamTimerOut,
  CodeSubmissionHistoryListOut,
  ExecuteSessionQuestionTestCasesIn,
  ExecuteSessionQuestionTestCasesOut,
  GeneralSessionDetailOut,
  GeneralSessionListOut,
  GeneralSessionRankingOut,
  GeneralSessionTermDetailOut,
  GeneralTermDetailOut,
  GetQuestionSampleCaseResultsOut,
  GetQuestionSampleCasesListOut,
  GetSessionTestCaseResultsOut,
  QuestionBlankExecuteIn,
  QuestionBlankExecuteOut,
  QuestionExecuteSampleCaseIn,
  QuestionExecuteSampleCaseOut,
  QuestionSelectionExecuteIn,
  QuestionSelectionExecuteOut,
  QuestionsStatusOut,
  SessionAnswerStatusOut,
  SessionPasswordVerificationIn,
  SessionSubmitCodeHistoryOut,
  SessionThreadListOut,
  ValidationError,
} from '../models/index';
import {
    ApiErrorFromJSON,
    ApiErrorToJSON,
    AppSchemasGeneralSessionsGeneralSessionContentListOutSessionContentListOutFromJSON,
    AppSchemasGeneralSessionsGeneralSessionContentListOutSessionContentListOutToJSON,
    CertificateExamTimerOutFromJSON,
    CertificateExamTimerOutToJSON,
    CodeSubmissionHistoryListOutFromJSON,
    CodeSubmissionHistoryListOutToJSON,
    ExecuteSessionQuestionTestCasesInFromJSON,
    ExecuteSessionQuestionTestCasesInToJSON,
    ExecuteSessionQuestionTestCasesOutFromJSON,
    ExecuteSessionQuestionTestCasesOutToJSON,
    GeneralSessionDetailOutFromJSON,
    GeneralSessionDetailOutToJSON,
    GeneralSessionListOutFromJSON,
    GeneralSessionListOutToJSON,
    GeneralSessionRankingOutFromJSON,
    GeneralSessionRankingOutToJSON,
    GeneralSessionTermDetailOutFromJSON,
    GeneralSessionTermDetailOutToJSON,
    GeneralTermDetailOutFromJSON,
    GeneralTermDetailOutToJSON,
    GetQuestionSampleCaseResultsOutFromJSON,
    GetQuestionSampleCaseResultsOutToJSON,
    GetQuestionSampleCasesListOutFromJSON,
    GetQuestionSampleCasesListOutToJSON,
    GetSessionTestCaseResultsOutFromJSON,
    GetSessionTestCaseResultsOutToJSON,
    QuestionBlankExecuteInFromJSON,
    QuestionBlankExecuteInToJSON,
    QuestionBlankExecuteOutFromJSON,
    QuestionBlankExecuteOutToJSON,
    QuestionExecuteSampleCaseInFromJSON,
    QuestionExecuteSampleCaseInToJSON,
    QuestionExecuteSampleCaseOutFromJSON,
    QuestionExecuteSampleCaseOutToJSON,
    QuestionSelectionExecuteInFromJSON,
    QuestionSelectionExecuteInToJSON,
    QuestionSelectionExecuteOutFromJSON,
    QuestionSelectionExecuteOutToJSON,
    QuestionsStatusOutFromJSON,
    QuestionsStatusOutToJSON,
    SessionAnswerStatusOutFromJSON,
    SessionAnswerStatusOutToJSON,
    SessionPasswordVerificationInFromJSON,
    SessionPasswordVerificationInToJSON,
    SessionSubmitCodeHistoryOutFromJSON,
    SessionSubmitCodeHistoryOutToJSON,
    SessionThreadListOutFromJSON,
    SessionThreadListOutToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models/index';

export interface AgreeGeneralSessionTermRequest {
    sessionCode: string;
}

export interface CreateThreadReadRequest {
    sessionId: number;
}

export interface EntrySessionRequest {
    sessionCode: string;
}

export interface ExecuteSessionQuestionSampleCasesRequest {
    sessionId: number;
    contentId: number;
    questionExecuteSampleCaseIn: QuestionExecuteSampleCaseIn;
}

export interface ExecuteSessionQuestionTestCasesRequest {
    sessionId: number;
    contentId: number;
    executeSessionQuestionTestCasesIn: ExecuteSessionQuestionTestCasesIn;
}

export interface GeneralGetQuestionsAnswerStatusRequest {
    sessionId: number;
    contentId: number;
}

export interface GeneralPostQuestionsBlankExecuteRequest {
    sessionId: number;
    contentId: number;
    questionBlankExecuteIn: QuestionBlankExecuteIn;
}

export interface GeneralPostQuestionsSelectionExecuteRequest {
    sessionId: number;
    contentId: number;
    questionSelectionExecuteIn: QuestionSelectionExecuteIn;
}

export interface GetGeneralSessionContentListRequest {
    sessionId: number;
}

export interface GetGeneralSessionDetailRequest {
    sessionCode: string;
}

export interface GetGeneralSessionListRequest {
    eventId?: number;
    isInProgress?: boolean;
    isPickedUp?: boolean;
    limit?: number;
}

export interface GetGeneralSessionRankingRequest {
    sessionId: number;
    limit?: number;
    offset?: number;
}

export interface GetGeneralSessionTermRequest {
    sessionCode: string;
}

export interface GetGeneralSessionThreadListRequest {
    sessionId: number;
}

export interface GetSessionAnswerStatusRequest {
    sessionId: number;
}

export interface GetSessionQuestionSampleCaseListsRequest {
    sessionId: number;
    contentId: number;
}

export interface GetSessionQuestionSampleCaseResultsRequest {
    sessionId: number;
    contentId: number;
    testResultId: number;
    isLastQuery?: boolean;
}

export interface GetSessionQuestionTestCaseResultsRequest {
    sessionId: number;
    contentId: number;
    testResultId: number;
    isLastQuery?: boolean;
}

export interface GetSessionQuestionsTestResultsRequest {
    sessionId: number;
    contentId: number;
}

export interface GetSessionSubmittedCodeHistoryRequest {
    sessionId: number;
}

export interface StartCertificateExamTimerRequest {
    sessionId: number;
}

export interface StopCertificateExamTimerRequest {
    sessionId: number;
}

export interface VerifySessionPasswordRequest {
    sessionCode: string;
    sessionPasswordVerificationIn: SessionPasswordVerificationIn;
}

/**
 * 
 */
export class GeneralSessionsApi extends runtime.BaseAPI {

    /**
     * 人材紹介規約を同意 - 必要権限: [GENERAL_USER] - 実行条件:     - TermTypeが下記のみ実行する         - TermType.HR_PERSONAL_ID_INFO_TERM :\"人材紹介 個人情報規約\"         - TermType.HR_TERM_OF_USE :\"人材紹介 利用規約\"
     * 人材紹介規約を同意
     */
    async agreeGeneralHrTermRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/hr-terms`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 人材紹介規約を同意 - 必要権限: [GENERAL_USER] - 実行条件:     - TermTypeが下記のみ実行する         - TermType.HR_PERSONAL_ID_INFO_TERM :\"人材紹介 個人情報規約\"         - TermType.HR_TERM_OF_USE :\"人材紹介 利用規約\"
     * 人材紹介規約を同意
     */
    async agreeGeneralHrTerm(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.agreeGeneralHrTermRaw(initOverrides);
    }

    /**
     * セッション規約を同意 - RequestBody:なし - ResponseBody:なし - 必要権限: [GENERAL_USER] [SKILL_CHECK_USER] - 最新バージョンのセッション規約に同意した状態のSessionUserを作成する - 実行条件:     - Session.is_deleted=False     - セッション規約が存在すること(紐づいていること)         - ないときはDataDoesNotExistを返す     - SessionUserにuser.idがない場合: 新規登録する         - 登録データ             - セッションID             - ユーザーID             - セッションユーザステータス: SessionUserStatus.BEFORE_ANSWERING             - 最後に同意した規約ID(SessionTerm.id)             - 最後に同意した規約Version(SessionTerm.version)             - 開始日時:None             - 終了日時:None     - SessionUserにuser.idがある場合: 更新する         - 最後に同意した規約ID(SessionTerm.id)         - 最後に同意した規約Version(SessionTerm.version)
     * セッション規約を同意
     */
    async agreeGeneralSessionTermRaw(requestParameters: AgreeGeneralSessionTermRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.sessionCode === null || requestParameters.sessionCode === undefined) {
            throw new runtime.RequiredError('sessionCode','Required parameter requestParameters.sessionCode was null or undefined when calling agreeGeneralSessionTerm.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_code}/terms`.replace(`{${"session_code"}}`, encodeURIComponent(String(requestParameters.sessionCode))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * セッション規約を同意 - RequestBody:なし - ResponseBody:なし - 必要権限: [GENERAL_USER] [SKILL_CHECK_USER] - 最新バージョンのセッション規約に同意した状態のSessionUserを作成する - 実行条件:     - Session.is_deleted=False     - セッション規約が存在すること(紐づいていること)         - ないときはDataDoesNotExistを返す     - SessionUserにuser.idがない場合: 新規登録する         - 登録データ             - セッションID             - ユーザーID             - セッションユーザステータス: SessionUserStatus.BEFORE_ANSWERING             - 最後に同意した規約ID(SessionTerm.id)             - 最後に同意した規約Version(SessionTerm.version)             - 開始日時:None             - 終了日時:None     - SessionUserにuser.idがある場合: 更新する         - 最後に同意した規約ID(SessionTerm.id)         - 最後に同意した規約Version(SessionTerm.version)
     * セッション規約を同意
     */
    async agreeGeneralSessionTerm(requestParameters: AgreeGeneralSessionTermRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.agreeGeneralSessionTermRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 一般用セッションスレッド既読 スレッドタブ表示時に未読のスレッドを既読に変更 - 必要権限：[GENERAL_USER] - 登録条件：     - Session.is_deleted = True - 登録内容     - SessionThreadReadに登録されていないsession_idとuser_idのデータを登録する
     * セッションスレッド既読
     */
    async createThreadReadRaw(requestParameters: CreateThreadReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling createThreadRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/read-threads`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * 一般用セッションスレッド既読 スレッドタブ表示時に未読のスレッドを既読に変更 - 必要権限：[GENERAL_USER] - 登録条件：     - Session.is_deleted = True - 登録内容     - SessionThreadReadに登録されていないsession_idとuser_idのデータを登録する
     * セッションスレッド既読
     */
    async createThreadRead(requestParameters: CreateThreadReadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createThreadReadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッション参加 - 必要権限: [GENERAL_USER] [Pm.SKILL_CHECK_USER] - RequestBody:なし - ResponseBody:なし - 実行条件:     - SessionUserにuser.idが存在しない場合(PW入力・各種規約同意が要求されなかった場合)         - SessionUserを登録する
     * セッション参加
     */
    async entrySessionRaw(requestParameters: EntrySessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.sessionCode === null || requestParameters.sessionCode === undefined) {
            throw new runtime.RequiredError('sessionCode','Required parameter requestParameters.sessionCode was null or undefined when calling entrySession.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_code}/entry`.replace(`{${"session_code"}}`, encodeURIComponent(String(requestParameters.sessionCode))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * セッション参加 - 必要権限: [GENERAL_USER] [Pm.SKILL_CHECK_USER] - RequestBody:なし - ResponseBody:なし - 実行条件:     - SessionUserにuser.idが存在しない場合(PW入力・各種規約同意が要求されなかった場合)         - SessionUserを登録する
     * セッション参加
     */
    async entrySession(requestParameters: EntrySessionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.entrySessionRaw(requestParameters, initOverrides);
    }

    /**
     * セッション問題のサンプルケース実行 - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理     - セッションが存在しない(削除される)場合はエラー(NotFound)     - SessionUserに(session_id, user_id)が存在しない場合はエラー　(NotFound)     - 該当セッションが存在しない、またはイベントが存在しない場合はエラー(NotFound)     - 該当問題が存在しない場合はエラー(NotFound)         - SessionContentに(session_id, content_id)のデータが存在する         - Question.content_id = content_id         - Question.question_type in [QuestionType.CODING, QuestionType.FILLING, QuestionType.BUG]     - 該当言語が存在しない場合はエラー(NotFound)     - QuestionResultから該当するデータが取得できない場合はエラー(QuestionAnswerNotStarted)         - QuestionResult.user_id = user.id         - QuestionResult.question_id = Question.id         - QuestionResult.session_id = session_id         - QuestionResult.question_result_type in                 [QuestionResultType.SESSION, QuestionResultType.OLD_SESSION] - 処理手順     - QuestionResultを取得     - QuestionTestResultにデータを作成         - source_code: リクエストの値         - pg_lang_id: リクエストの値         - question_answer_result: QuestionAnswerResult.SCORING         - is_sample_case: True         - question_result_id: 上記で取得したQuestionResultのID     - QuestionTestCaseResultにテストケース毎のデータを作成         - question_test_result_id: 上記で作成したQuestionTestResultのID         - question_test_case_id: 対応するテストケースのID         - judge_status: JudgeStatus.WJ     - Judgeシステムの採点API実行
     * セッション問題サンプルケース実行
     */
    async executeSessionQuestionSampleCasesRaw(requestParameters: ExecuteSessionQuestionSampleCasesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionExecuteSampleCaseOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling executeSessionQuestionSampleCases.');
        }

        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling executeSessionQuestionSampleCases.');
        }

        if (requestParameters.questionExecuteSampleCaseIn === null || requestParameters.questionExecuteSampleCaseIn === undefined) {
            throw new runtime.RequiredError('questionExecuteSampleCaseIn','Required parameter requestParameters.questionExecuteSampleCaseIn was null or undefined when calling executeSessionQuestionSampleCases.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/general/sessions/{session_id}/questions/{content_id}/sample-cases/execute`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))).replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionExecuteSampleCaseInToJSON(requestParameters.questionExecuteSampleCaseIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionExecuteSampleCaseOutFromJSON(jsonValue));
    }

    /**
     * セッション問題のサンプルケース実行 - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理     - セッションが存在しない(削除される)場合はエラー(NotFound)     - SessionUserに(session_id, user_id)が存在しない場合はエラー　(NotFound)     - 該当セッションが存在しない、またはイベントが存在しない場合はエラー(NotFound)     - 該当問題が存在しない場合はエラー(NotFound)         - SessionContentに(session_id, content_id)のデータが存在する         - Question.content_id = content_id         - Question.question_type in [QuestionType.CODING, QuestionType.FILLING, QuestionType.BUG]     - 該当言語が存在しない場合はエラー(NotFound)     - QuestionResultから該当するデータが取得できない場合はエラー(QuestionAnswerNotStarted)         - QuestionResult.user_id = user.id         - QuestionResult.question_id = Question.id         - QuestionResult.session_id = session_id         - QuestionResult.question_result_type in                 [QuestionResultType.SESSION, QuestionResultType.OLD_SESSION] - 処理手順     - QuestionResultを取得     - QuestionTestResultにデータを作成         - source_code: リクエストの値         - pg_lang_id: リクエストの値         - question_answer_result: QuestionAnswerResult.SCORING         - is_sample_case: True         - question_result_id: 上記で取得したQuestionResultのID     - QuestionTestCaseResultにテストケース毎のデータを作成         - question_test_result_id: 上記で作成したQuestionTestResultのID         - question_test_case_id: 対応するテストケースのID         - judge_status: JudgeStatus.WJ     - Judgeシステムの採点API実行
     * セッション問題サンプルケース実行
     */
    async executeSessionQuestionSampleCases(requestParameters: ExecuteSessionQuestionSampleCasesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionExecuteSampleCaseOut> {
        const response = await this.executeSessionQuestionSampleCasesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッション問題のテストケース実行 - チャレンジ問題等に使用し、セッション問題には使用しない - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理     - 該当セッションが存在しない、またはイベントが存在しない場合はエラー(NotFound)     - SessionUserに(user_id, session_id)のデータが存在しない(NotFound)     - 該当問題が存在しない場合はエラー(NotFound)         - Content.is_deleted = False         - SessionContentに(session_id, content_id)のデータが存在する         - Question.content_id = content_id         - Question.question_type in [QuestionType.CODING, QuestionType.FILLING, QuestionType.BUG]     - 該当言語が存在しない場合はエラー(NotFound)     - QuestionResultから該当するデータが取得できない場合はエラー(QuestionAnswerNotStarted)         - QuestionResult.user_id = user.id         - QuestionResult.question_id = Question.id         - QuestionResult.session_id = session_id         - QuestionResult.question_result_type in                 [QuestionResultType.SESSION, QuestionResultType.OLD_SESSION] - 処理手順     - QuestionResultを取得     - QuestionTestResultにデータを作成         - source_code: リクエストの値         - pg_lang_id: リクエストの値         - question_answer_result: QuestionAnswerResult.SCORING         - is_sample_case: False         - question_result_id: 上記で取得したQuestionResultのID     - QuestionTestCaseResultにテストケース毎のデータを作成         - question_test_result_id: 上記で作成したQuestionTestResultのID         - question_test_case_id: 対応するテストケースのID         - judge_status: JudgeStatus.WJ     - Judgeシステムの採点API実行
     * セッション問題テストケース実行
     */
    async executeSessionQuestionTestCasesRaw(requestParameters: ExecuteSessionQuestionTestCasesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ExecuteSessionQuestionTestCasesOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling executeSessionQuestionTestCases.');
        }

        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling executeSessionQuestionTestCases.');
        }

        if (requestParameters.executeSessionQuestionTestCasesIn === null || requestParameters.executeSessionQuestionTestCasesIn === undefined) {
            throw new runtime.RequiredError('executeSessionQuestionTestCasesIn','Required parameter requestParameters.executeSessionQuestionTestCasesIn was null or undefined when calling executeSessionQuestionTestCases.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/general/sessions/{session_id}/questions/{content_id}/test-cases/execute`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))).replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExecuteSessionQuestionTestCasesInToJSON(requestParameters.executeSessionQuestionTestCasesIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExecuteSessionQuestionTestCasesOutFromJSON(jsonValue));
    }

    /**
     * セッション問題のテストケース実行 - チャレンジ問題等に使用し、セッション問題には使用しない - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理     - 該当セッションが存在しない、またはイベントが存在しない場合はエラー(NotFound)     - SessionUserに(user_id, session_id)のデータが存在しない(NotFound)     - 該当問題が存在しない場合はエラー(NotFound)         - Content.is_deleted = False         - SessionContentに(session_id, content_id)のデータが存在する         - Question.content_id = content_id         - Question.question_type in [QuestionType.CODING, QuestionType.FILLING, QuestionType.BUG]     - 該当言語が存在しない場合はエラー(NotFound)     - QuestionResultから該当するデータが取得できない場合はエラー(QuestionAnswerNotStarted)         - QuestionResult.user_id = user.id         - QuestionResult.question_id = Question.id         - QuestionResult.session_id = session_id         - QuestionResult.question_result_type in                 [QuestionResultType.SESSION, QuestionResultType.OLD_SESSION] - 処理手順     - QuestionResultを取得     - QuestionTestResultにデータを作成         - source_code: リクエストの値         - pg_lang_id: リクエストの値         - question_answer_result: QuestionAnswerResult.SCORING         - is_sample_case: False         - question_result_id: 上記で取得したQuestionResultのID     - QuestionTestCaseResultにテストケース毎のデータを作成         - question_test_result_id: 上記で作成したQuestionTestResultのID         - question_test_case_id: 対応するテストケースのID         - judge_status: JudgeStatus.WJ     - Judgeシステムの採点API実行
     * セッション問題テストケース実行
     */
    async executeSessionQuestionTestCases(requestParameters: ExecuteSessionQuestionTestCasesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ExecuteSessionQuestionTestCasesOut> {
        const response = await this.executeSessionQuestionTestCasesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * twitterで直接IDを叩いた時にすぐ始まっちゃうのを防ぐために必要 問題詳細画面を開くときに使用し、チャレンジ問題かつ未解答の場合はポップアップ表示するために必要 - 必要権限: [GENERAL_USER] - 取得条件:     - content_type: GENERAL     - Content.is_deleted = False     - Event.is_deleted=False     - Session.is_deleted=False     - セッションコンテンツに含まれている(session_id,content_id) - レスポンス:     - 問題の解答状況 - 備考:     - 未解答とはQuestionResultテーブルにレコードが1件も存在しない場合を指す - 処理内容:     - QuestionResultに該当ユーザの該当問題のレコードが存在するかチェック     - チェック結果を返す
     * セッション問題解答状況取得
     */
    async generalGetQuestionsAnswerStatusRaw(requestParameters: GeneralGetQuestionsAnswerStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionsStatusOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling generalGetQuestionsAnswerStatus.');
        }

        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling generalGetQuestionsAnswerStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/questions/{content_id}/answer-status`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))).replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionsStatusOutFromJSON(jsonValue));
    }

    /**
     * twitterで直接IDを叩いた時にすぐ始まっちゃうのを防ぐために必要 問題詳細画面を開くときに使用し、チャレンジ問題かつ未解答の場合はポップアップ表示するために必要 - 必要権限: [GENERAL_USER] - 取得条件:     - content_type: GENERAL     - Content.is_deleted = False     - Event.is_deleted=False     - Session.is_deleted=False     - セッションコンテンツに含まれている(session_id,content_id) - レスポンス:     - 問題の解答状況 - 備考:     - 未解答とはQuestionResultテーブルにレコードが1件も存在しない場合を指す - 処理内容:     - QuestionResultに該当ユーザの該当問題のレコードが存在するかチェック     - チェック結果を返す
     * セッション問題解答状況取得
     */
    async generalGetQuestionsAnswerStatus(requestParameters: GeneralGetQuestionsAnswerStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionsStatusOut> {
        const response = await this.generalGetQuestionsAnswerStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッション空欄問題採点実行 - セッションで使用される空欄問題 - 必要権限: [GENERAL_USER] - レスポンス:     - 採点結果とQuestionの解答と各空欄の採点結果 - 処理内容:     - session_idのSessionレコードが削除済みか、存在しない場合エラー(NotFound)     - SessionUserに(session_id, user_id)が存在しない場合はエラー(PermissionDenied)     - 該当問題が存在しない場合エラー(NotFound)     - QuestionResultにレコードが存在しない場合エラー(QuestionAnswerNotStarted)     - 採点を実行         - 該当問題のQuestionBlankのanswerと一致しているか各解答をチェック         - 全問題一致しているなら正解、1問でも不一致なら不正解     - QuestionBlankResultにデータを作成         - question_result_id: QuestionResultのID         - is_correct: 上記の採点結果(True or False)         - score: 0         - is_used_for_result: 上記の採点結果(True or False)     - QuestionBlankEachResultに送られてきた選択肢毎のデータを作成         - question_blank_id: 該当問題の空欄ID         - question_blank_result_id: 上記で作成したQuestionBlankResultのID         - answer: 空欄IDに対応するリクエストで送られてきたユーザの解答テキスト         - is_correct: 対象空欄の採点結果(True or False)     - QuestionResultに結果を書き込む         - question_result_status: QuestionResultStatus.PASS or QuestionResultStatus.ANSWERING - 補足情報:     - 空欄問題に点数はつけないためスコアは0点とする(将来的に点数はつける予定)     - 空欄問題はJudgeシステムで採点は行わない
     * セッション空欄問題採点実行
     */
    async generalPostQuestionsBlankExecuteRaw(requestParameters: GeneralPostQuestionsBlankExecuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionBlankExecuteOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling generalPostQuestionsBlankExecute.');
        }

        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling generalPostQuestionsBlankExecute.');
        }

        if (requestParameters.questionBlankExecuteIn === null || requestParameters.questionBlankExecuteIn === undefined) {
            throw new runtime.RequiredError('questionBlankExecuteIn','Required parameter requestParameters.questionBlankExecuteIn was null or undefined when calling generalPostQuestionsBlankExecute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/general/sessions/{session_id}/question/{content_id}/blank/execute`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))).replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionBlankExecuteInToJSON(requestParameters.questionBlankExecuteIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionBlankExecuteOutFromJSON(jsonValue));
    }

    /**
     * セッション空欄問題採点実行 - セッションで使用される空欄問題 - 必要権限: [GENERAL_USER] - レスポンス:     - 採点結果とQuestionの解答と各空欄の採点結果 - 処理内容:     - session_idのSessionレコードが削除済みか、存在しない場合エラー(NotFound)     - SessionUserに(session_id, user_id)が存在しない場合はエラー(PermissionDenied)     - 該当問題が存在しない場合エラー(NotFound)     - QuestionResultにレコードが存在しない場合エラー(QuestionAnswerNotStarted)     - 採点を実行         - 該当問題のQuestionBlankのanswerと一致しているか各解答をチェック         - 全問題一致しているなら正解、1問でも不一致なら不正解     - QuestionBlankResultにデータを作成         - question_result_id: QuestionResultのID         - is_correct: 上記の採点結果(True or False)         - score: 0         - is_used_for_result: 上記の採点結果(True or False)     - QuestionBlankEachResultに送られてきた選択肢毎のデータを作成         - question_blank_id: 該当問題の空欄ID         - question_blank_result_id: 上記で作成したQuestionBlankResultのID         - answer: 空欄IDに対応するリクエストで送られてきたユーザの解答テキスト         - is_correct: 対象空欄の採点結果(True or False)     - QuestionResultに結果を書き込む         - question_result_status: QuestionResultStatus.PASS or QuestionResultStatus.ANSWERING - 補足情報:     - 空欄問題に点数はつけないためスコアは0点とする(将来的に点数はつける予定)     - 空欄問題はJudgeシステムで採点は行わない
     * セッション空欄問題採点実行
     */
    async generalPostQuestionsBlankExecute(requestParameters: GeneralPostQuestionsBlankExecuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionBlankExecuteOut> {
        const response = await this.generalPostQuestionsBlankExecuteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッション選択式問題採点実行 - セッション問題に使用し、チャレンジ問題等には使用しない - 必要権限: [GENERAL_USER] - レスポンス:     - 採点結果とQuestionの解答 - 処理内容:     - 該当問題が存在しない場合エラー(NotFound)     - QuestionResultにレコードが存在しない場合エラー(QuestionAnswerNotStarted)     - 採点を実行         - ユーザが選択したorderの中で該当問題のQuestionChoiceのis_correct=Falseがある場合不正解         - そうでなければ正解     - QuestionChoiceResultにデータを作成         - question_result_id: QuestionResultのID         - score: 0         - is_correct: 上記の採点結果(True or False)         - is_used_for_result: 上記の採点結果(True or False)     - QuestionChoiceResultRelationに送られてきた選択肢毎のデータを作成         - question_choice_id: ユーザが選択した選択肢のID         - question_choice_result_id: 上記で作成したQuestionChoiceResultのID - 補足情報:     - 選択式問題に点数はつけないためスコアは0点とする(将来的に点数はつける予定)     - 選択式問題はJudgeシステムで採点は行わない
     * セッション選択式問題採点実行
     */
    async generalPostQuestionsSelectionExecuteRaw(requestParameters: GeneralPostQuestionsSelectionExecuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QuestionSelectionExecuteOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling generalPostQuestionsSelectionExecute.');
        }

        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling generalPostQuestionsSelectionExecute.');
        }

        if (requestParameters.questionSelectionExecuteIn === null || requestParameters.questionSelectionExecuteIn === undefined) {
            throw new runtime.RequiredError('questionSelectionExecuteIn','Required parameter requestParameters.questionSelectionExecuteIn was null or undefined when calling generalPostQuestionsSelectionExecute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/general/sessions/{session_id}/questions/{content_id}/selection/execute`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))).replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QuestionSelectionExecuteInToJSON(requestParameters.questionSelectionExecuteIn),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QuestionSelectionExecuteOutFromJSON(jsonValue));
    }

    /**
     * セッション選択式問題採点実行 - セッション問題に使用し、チャレンジ問題等には使用しない - 必要権限: [GENERAL_USER] - レスポンス:     - 採点結果とQuestionの解答 - 処理内容:     - 該当問題が存在しない場合エラー(NotFound)     - QuestionResultにレコードが存在しない場合エラー(QuestionAnswerNotStarted)     - 採点を実行         - ユーザが選択したorderの中で該当問題のQuestionChoiceのis_correct=Falseがある場合不正解         - そうでなければ正解     - QuestionChoiceResultにデータを作成         - question_result_id: QuestionResultのID         - score: 0         - is_correct: 上記の採点結果(True or False)         - is_used_for_result: 上記の採点結果(True or False)     - QuestionChoiceResultRelationに送られてきた選択肢毎のデータを作成         - question_choice_id: ユーザが選択した選択肢のID         - question_choice_result_id: 上記で作成したQuestionChoiceResultのID - 補足情報:     - 選択式問題に点数はつけないためスコアは0点とする(将来的に点数はつける予定)     - 選択式問題はJudgeシステムで採点は行わない
     * セッション選択式問題採点実行
     */
    async generalPostQuestionsSelectionExecute(requestParameters: GeneralPostQuestionsSelectionExecuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QuestionSelectionExecuteOut> {
        const response = await this.generalPostQuestionsSelectionExecuteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 人材紹介規約を取得 - 必要権限: [GENERAL_USER] - 下記の最新版規約を取得する     - TermType.HR_PERSONAL_ID_INFO_TERM :\"人材紹介 個人情報規約\"     - TermType.HR_TERM_OF_USE :\"人材紹介 利用規約\"
     * 人材紹介規約を取得
     */
    async getGeneralHrTermRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GeneralTermDetailOut>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/hr-terms`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GeneralTermDetailOutFromJSON(jsonValue));
    }

    /**
     * 人材紹介規約を取得 - 必要権限: [GENERAL_USER] - 下記の最新版規約を取得する     - TermType.HR_PERSONAL_ID_INFO_TERM :\"人材紹介 個人情報規約\"     - TermType.HR_TERM_OF_USE :\"人材紹介 利用規約\"
     * 人材紹介規約を取得
     */
    async getGeneralHrTerm(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GeneralTermDetailOut> {
        const response = await this.getGeneralHrTermRaw(initOverrides);
        return await response.value();
    }

    /**
     * 一般ユーザー用セッションコンテンツ一覧取得 - 必要権限: [GENERAL_USER] - 並び順: order昇順 - session_idのセッションが削除済み、存在しない場合NotFound
     * 一般ユーザー用セッションコンテンツ一覧取得
     */
    async getGeneralSessionContentListRaw(requestParameters: GetGeneralSessionContentListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<AppSchemasGeneralSessionsGeneralSessionContentListOutSessionContentListOut>>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling getGeneralSessionContentList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/contents`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AppSchemasGeneralSessionsGeneralSessionContentListOutSessionContentListOutFromJSON));
    }

    /**
     * 一般ユーザー用セッションコンテンツ一覧取得 - 必要権限: [GENERAL_USER] - 並び順: order昇順 - session_idのセッションが削除済み、存在しない場合NotFound
     * 一般ユーザー用セッションコンテンツ一覧取得
     */
    async getGeneralSessionContentList(requestParameters: GetGeneralSessionContentListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<AppSchemasGeneralSessionsGeneralSessionContentListOutSessionContentListOut>> {
        const response = await this.getGeneralSessionContentListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 一般ユーザ/スキルチェックユーザー用セッション詳細情報取得 - 必要権限: [GENERAL_USER] [SKILL_CHECK_USER] - 取得可能条件     - ユーザーがSessionUserに登録されている(セッションに参加している) - Response:     - 下記条件に該当しないか確認する             - セッション参加済みユーザーでない(SessionUserモデルにUserIDが存在しない)             - 卒業年度が対象の卒業年度内でない             - 最新の人材紹介規約の同意していない             - PWを入力して参加していない             - 最新のセッション規約の同意していない             - 一般ユーザがスキルチェックセッションにアクセスする             - スキルチェックユーザがスキルチェックセッション以外にアクセスする     - 404: NotFound         - is_deleted = True         - 存在しないsession_code TODO:API実行時間が15〜20sかかる
     * 一般ユーザ用セッション詳細情報取得
     */
    async getGeneralSessionDetailRaw(requestParameters: GetGeneralSessionDetailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GeneralSessionDetailOut>> {
        if (requestParameters.sessionCode === null || requestParameters.sessionCode === undefined) {
            throw new runtime.RequiredError('sessionCode','Required parameter requestParameters.sessionCode was null or undefined when calling getGeneralSessionDetail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_code}`.replace(`{${"session_code"}}`, encodeURIComponent(String(requestParameters.sessionCode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GeneralSessionDetailOutFromJSON(jsonValue));
    }

    /**
     * 一般ユーザ/スキルチェックユーザー用セッション詳細情報取得 - 必要権限: [GENERAL_USER] [SKILL_CHECK_USER] - 取得可能条件     - ユーザーがSessionUserに登録されている(セッションに参加している) - Response:     - 下記条件に該当しないか確認する             - セッション参加済みユーザーでない(SessionUserモデルにUserIDが存在しない)             - 卒業年度が対象の卒業年度内でない             - 最新の人材紹介規約の同意していない             - PWを入力して参加していない             - 最新のセッション規約の同意していない             - 一般ユーザがスキルチェックセッションにアクセスする             - スキルチェックユーザがスキルチェックセッション以外にアクセスする     - 404: NotFound         - is_deleted = True         - 存在しないsession_code TODO:API実行時間が15〜20sかかる
     * 一般ユーザ用セッション詳細情報取得
     */
    async getGeneralSessionDetail(requestParameters: GetGeneralSessionDetailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GeneralSessionDetailOut> {
        const response = await this.getGeneralSessionDetailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッション一覧を取得 - 必要権限: [GENERAL_USER] [SKILL_CHECK_USER] - 並び順:開始日時の昇順 - レスポンスデータ補足情報     - is_active: セッションが一時停止中か     - sessions         - session_user_count: セッション参加ユーザーの合計         - session_status         　- 開催予定: セッション開始日時 > 現在日時         　- 開催中: セッション開始日時 <= 現在日時 <= セッション終了日時         　- 終了: 現在日時 > セッション終了日時 - 取得可能条件     - is_deleted = False     - event_idなしの場合NotFound
     * 一般ユーザー用セッション一覧を取得
     */
    async getGeneralSessionListRaw(requestParameters: GetGeneralSessionListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GeneralSessionListOut>>> {
        const queryParameters: any = {};

        if (requestParameters.eventId !== undefined) {
            queryParameters['event_id'] = requestParameters.eventId;
        }

        if (requestParameters.isInProgress !== undefined) {
            queryParameters['is_in_progress'] = requestParameters.isInProgress;
        }

        if (requestParameters.isPickedUp !== undefined) {
            queryParameters['is_picked_up'] = requestParameters.isPickedUp;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GeneralSessionListOutFromJSON));
    }

    /**
     * セッション一覧を取得 - 必要権限: [GENERAL_USER] [SKILL_CHECK_USER] - 並び順:開始日時の昇順 - レスポンスデータ補足情報     - is_active: セッションが一時停止中か     - sessions         - session_user_count: セッション参加ユーザーの合計         - session_status         　- 開催予定: セッション開始日時 > 現在日時         　- 開催中: セッション開始日時 <= 現在日時 <= セッション終了日時         　- 終了: 現在日時 > セッション終了日時 - 取得可能条件     - is_deleted = False     - event_idなしの場合NotFound
     * 一般ユーザー用セッション一覧を取得
     */
    async getGeneralSessionList(requestParameters: GetGeneralSessionListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GeneralSessionListOut>> {
        const response = await this.getGeneralSessionListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 一般ユーザー側のセッションランキング取得 - 必要権限: [GENERAL_USER] [SKILL_CHECK_USER] - 並び順:     - スコアの降順     - 同点の場合はスコア到達時間の昇順 - レスポンス     - 対象ユーザーの順位     - セッションの参加人数     - offsetを考慮したlimit数分のランキングデータ - セッションが存在しない場合、NotFound - ランキングデータに表示する内容     - 444主催イベントの場合         - 順位 表示名 都道府県 スコア 合格問題数 合計解答時間     - 学校イベントの場合         - 順位 表示名 スコア     - スキルチェックの場合         - 順位 表示名 スコア - 補足     - ページネーションにより表示するランキングが変化する     - offsetで何ページの順位を表示するか決まる
     * 一般ユーザー用セッションランキング取得
     */
    async getGeneralSessionRankingRaw(requestParameters: GetGeneralSessionRankingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GeneralSessionRankingOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling getGeneralSessionRanking.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/ranking`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GeneralSessionRankingOutFromJSON(jsonValue));
    }

    /**
     * 一般ユーザー側のセッションランキング取得 - 必要権限: [GENERAL_USER] [SKILL_CHECK_USER] - 並び順:     - スコアの降順     - 同点の場合はスコア到達時間の昇順 - レスポンス     - 対象ユーザーの順位     - セッションの参加人数     - offsetを考慮したlimit数分のランキングデータ - セッションが存在しない場合、NotFound - ランキングデータに表示する内容     - 444主催イベントの場合         - 順位 表示名 都道府県 スコア 合格問題数 合計解答時間     - 学校イベントの場合         - 順位 表示名 スコア     - スキルチェックの場合         - 順位 表示名 スコア - 補足     - ページネーションにより表示するランキングが変化する     - offsetで何ページの順位を表示するか決まる
     * 一般ユーザー用セッションランキング取得
     */
    async getGeneralSessionRanking(requestParameters: GetGeneralSessionRankingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GeneralSessionRankingOut> {
        const response = await this.getGeneralSessionRankingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッション規約を取得(一般用) - 必要権限: [GENERAL_USER] [SKILL_CHECK_USER] - 実行条件     - Session.is_deleted=False     - セッション規約が存在すること(紐づいていること)         - ないときはDataDoesNotExistを返す
     * セッション規約を取得(一般用)
     */
    async getGeneralSessionTermRaw(requestParameters: GetGeneralSessionTermRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GeneralSessionTermDetailOut>> {
        if (requestParameters.sessionCode === null || requestParameters.sessionCode === undefined) {
            throw new runtime.RequiredError('sessionCode','Required parameter requestParameters.sessionCode was null or undefined when calling getGeneralSessionTerm.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_code}/terms`.replace(`{${"session_code"}}`, encodeURIComponent(String(requestParameters.sessionCode))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GeneralSessionTermDetailOutFromJSON(jsonValue));
    }

    /**
     * セッション規約を取得(一般用) - 必要権限: [GENERAL_USER] [SKILL_CHECK_USER] - 実行条件     - Session.is_deleted=False     - セッション規約が存在すること(紐づいていること)         - ないときはDataDoesNotExistを返す
     * セッション規約を取得(一般用)
     */
    async getGeneralSessionTerm(requestParameters: GetGeneralSessionTermRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GeneralSessionTermDetailOut> {
        const response = await this.getGeneralSessionTermRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッションスレッド投稿の一覧取得 - 必要権限: [OWN_SESSION_VIEW] - session_idに紐づくスレッドを一覧取得 - session_idのセッションが削除済み、存在しない場合NotFound - id降順に取得
     * 一般用セッションスレッド一覧取得
     */
    async getGeneralSessionThreadListRaw(requestParameters: GetGeneralSessionThreadListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SessionThreadListOut>>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling getGeneralSessionThreadList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/threads`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SessionThreadListOutFromJSON));
    }

    /**
     * セッションスレッド投稿の一覧取得 - 必要権限: [OWN_SESSION_VIEW] - session_idに紐づくスレッドを一覧取得 - session_idのセッションが削除済み、存在しない場合NotFound - id降順に取得
     * 一般用セッションスレッド一覧取得
     */
    async getGeneralSessionThreadList(requestParameters: GetGeneralSessionThreadListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SessionThreadListOut>> {
        const response = await this.getGeneralSessionThreadListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッション解答状況一覧取得 - 必要権限：[GENERAL_USER]     - 一般ユーザーのみ実行可能 - session_idに紐づくセッションコンテンツへのログインユーザーの解答状況を取得 - ”未解答”ステータス(QuestionResult.question_result_status.UNANSWERED)の問題は表示しない - session_idのセッションが削除済み、存在しない場合NotFound
     * セッション解答状況取得
     */
    async getSessionAnswerStatusRaw(requestParameters: GetSessionAnswerStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SessionAnswerStatusOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling getSessionAnswerStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/answer_status`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SessionAnswerStatusOutFromJSON(jsonValue));
    }

    /**
     * セッション解答状況一覧取得 - 必要権限：[GENERAL_USER]     - 一般ユーザーのみ実行可能 - session_idに紐づくセッションコンテンツへのログインユーザーの解答状況を取得 - ”未解答”ステータス(QuestionResult.question_result_status.UNANSWERED)の問題は表示しない - session_idのセッションが削除済み、存在しない場合NotFound
     * セッション解答状況取得
     */
    async getSessionAnswerStatus(requestParameters: GetSessionAnswerStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SessionAnswerStatusOut> {
        const response = await this.getSessionAnswerStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 問題サンプルケース一覧取得 - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理:     - 該当セッションが存在しない場合: NotFound     - SessionContentsにはsession_idとcontent_idの組み合わせが存在しない場合: NotFound     - 該当問題が存在しない場合: NotFound - 並び順: QuestionTestCase.order - データ取得可能条件:     - Question.content_id = content_id     - QuestionTestCase.is_sample_case = True - レスポンス補足:     - QuestionTestCase.is_omitted がTrueの場合、shorten_stdin、shorten_stdoutを返す
     * セッション問題テストケース取得
     */
    async getSessionQuestionSampleCaseListsRaw(requestParameters: GetSessionQuestionSampleCaseListsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GetQuestionSampleCasesListOut>>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling getSessionQuestionSampleCaseLists.');
        }

        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getSessionQuestionSampleCaseLists.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/questions/{content_id}/sample-cases`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))).replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GetQuestionSampleCasesListOutFromJSON));
    }

    /**
     * 問題サンプルケース一覧取得 - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理:     - 該当セッションが存在しない場合: NotFound     - SessionContentsにはsession_idとcontent_idの組み合わせが存在しない場合: NotFound     - 該当問題が存在しない場合: NotFound - 並び順: QuestionTestCase.order - データ取得可能条件:     - Question.content_id = content_id     - QuestionTestCase.is_sample_case = True - レスポンス補足:     - QuestionTestCase.is_omitted がTrueの場合、shorten_stdin、shorten_stdoutを返す
     * セッション問題テストケース取得
     */
    async getSessionQuestionSampleCaseLists(requestParameters: GetSessionQuestionSampleCaseListsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GetQuestionSampleCasesListOut>> {
        const response = await this.getSessionQuestionSampleCaseListsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッション問題サンプルケース結果取得  - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理     - セッションが存在しない(削除される)場合はエラー(NotFound)     - SessionUserに(session_id, user_id)が存在しない場合はエラー　(PermissionDenied)     - 該当セッションが存在しない、またはイベントが存在しない場合はエラー(NotFound)     - 該当問題が存在しない場合はエラー(NotFound)         - Content.is_deleted = False         - SessionContentに(session_id, content_id)のデータが存在する         - Question.content_id = content_id         - Question.question_type in [QuestionType.CORDING, QuestionType.FILLING, QuestionType.BUG]     - 該当QuestionResultが存在しない場合はエラー(NotFound)         - session_id, question_id, user_idが一致するデータが存在する     - 該当QuestionTestResultが存在しない場合はエラー(NotFound)         - 上記取得したQuestionResult.idと一致するデータが存在する - 並び順: QuestionTestCase.order昇順 - 処理手順     - 該当QuestionTestResultを取得する     - 最後のポーリングである場合、もし全部のケースが取得できなければ、サーバーエラーと判定し、            QuestionTestResultのquestion_answer_resultをSERVER_ERRORに更新する     - 全部のケースが取得できた場合、結果を返す、 - 備考:     - 一旦ポーリングの最大回数を超えてサーバーエラーに判定されたら、QuestionTestResultのquestion_answer_resultは変えないようにする     (\"app/services/judge_result/judge_result_question.py\"を修正する必要があるかもしれません)
     * セッション問題サンプルケース結果取得
     */
    async getSessionQuestionSampleCaseResultsRaw(requestParameters: GetSessionQuestionSampleCaseResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetQuestionSampleCaseResultsOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling getSessionQuestionSampleCaseResults.');
        }

        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getSessionQuestionSampleCaseResults.');
        }

        if (requestParameters.testResultId === null || requestParameters.testResultId === undefined) {
            throw new runtime.RequiredError('testResultId','Required parameter requestParameters.testResultId was null or undefined when calling getSessionQuestionSampleCaseResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.isLastQuery !== undefined) {
            queryParameters['is_last_query'] = requestParameters.isLastQuery;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/questions/{content_id}/test-results/{test_result_id}/sample-case`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))).replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))).replace(`{${"test_result_id"}}`, encodeURIComponent(String(requestParameters.testResultId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetQuestionSampleCaseResultsOutFromJSON(jsonValue));
    }

    /**
     * セッション問題サンプルケース結果取得  - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理     - セッションが存在しない(削除される)場合はエラー(NotFound)     - SessionUserに(session_id, user_id)が存在しない場合はエラー　(PermissionDenied)     - 該当セッションが存在しない、またはイベントが存在しない場合はエラー(NotFound)     - 該当問題が存在しない場合はエラー(NotFound)         - Content.is_deleted = False         - SessionContentに(session_id, content_id)のデータが存在する         - Question.content_id = content_id         - Question.question_type in [QuestionType.CORDING, QuestionType.FILLING, QuestionType.BUG]     - 該当QuestionResultが存在しない場合はエラー(NotFound)         - session_id, question_id, user_idが一致するデータが存在する     - 該当QuestionTestResultが存在しない場合はエラー(NotFound)         - 上記取得したQuestionResult.idと一致するデータが存在する - 並び順: QuestionTestCase.order昇順 - 処理手順     - 該当QuestionTestResultを取得する     - 最後のポーリングである場合、もし全部のケースが取得できなければ、サーバーエラーと判定し、            QuestionTestResultのquestion_answer_resultをSERVER_ERRORに更新する     - 全部のケースが取得できた場合、結果を返す、 - 備考:     - 一旦ポーリングの最大回数を超えてサーバーエラーに判定されたら、QuestionTestResultのquestion_answer_resultは変えないようにする     (\"app/services/judge_result/judge_result_question.py\"を修正する必要があるかもしれません)
     * セッション問題サンプルケース結果取得
     */
    async getSessionQuestionSampleCaseResults(requestParameters: GetSessionQuestionSampleCaseResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetQuestionSampleCaseResultsOut> {
        const response = await this.getSessionQuestionSampleCaseResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッション問題テストケース実行結果取得 - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理     - セッションが存在しない(削除される)場合はエラー(NotFound)     - SessionUserに(session_id, user_id)が存在しない場合はエラー　(PermissionDenied)     - 該当セッションが存在しない、またはイベントが存在しない場合はエラー(NotFound)     - 該当問題が存在しない場合はエラー(NotFound)         - Content.is_deleted = False         - SessionContentに(session_id, content_id)のデータが存在する         - Question.content_id = content_id         - Question.question_type in [QuestionType.CODING, QuestionType.FILLING, QuestionType.BUG]     - 該当QuestionResultが存在しない場合はエラー(NotFound)         - session_id, question_id, user_idが一致するデータが存在する     - 該当QuestionTestResultが存在しない場合はエラー(NotFound)         - 上記取得したQuestionResult.idと一致するデータが存在する         - is_sample_case = False - 並び順: QuestionTestCase.order昇順 - 処理手順     - 該当QuestionTestResultを取得する     - 最後のポーリングである場合、もし全部のケースが取得できなければ、サーバーエラーと判定し、            QuestionTestResultのquestion_answer_resultをSERVER_ERRORに更新する     - 全部のケースが取得できた場合、結果を返す、 - 備考:     - 一旦ポーリングの最大回数を超えてサーバーエラーに判定されたら、QuestionTestResultのquestion_answer_resultは変えないようにする     - セッション終了後は提出はできるが、点数に反映させない処理が必要です。     (\"app/services/judge_result/judge_result_question.py\"を修正する必要があるかもしれません)
     * セッション問題テストケース実行結果取得
     */
    async getSessionQuestionTestCaseResultsRaw(requestParameters: GetSessionQuestionTestCaseResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSessionTestCaseResultsOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling getSessionQuestionTestCaseResults.');
        }

        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getSessionQuestionTestCaseResults.');
        }

        if (requestParameters.testResultId === null || requestParameters.testResultId === undefined) {
            throw new runtime.RequiredError('testResultId','Required parameter requestParameters.testResultId was null or undefined when calling getSessionQuestionTestCaseResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.isLastQuery !== undefined) {
            queryParameters['is_last_query'] = requestParameters.isLastQuery;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/questions/{content_id}/test-results/{test_result_id}/test-case`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))).replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))).replace(`{${"test_result_id"}}`, encodeURIComponent(String(requestParameters.testResultId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetSessionTestCaseResultsOutFromJSON(jsonValue));
    }

    /**
     * セッション問題テストケース実行結果取得 - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理     - セッションが存在しない(削除される)場合はエラー(NotFound)     - SessionUserに(session_id, user_id)が存在しない場合はエラー　(PermissionDenied)     - 該当セッションが存在しない、またはイベントが存在しない場合はエラー(NotFound)     - 該当問題が存在しない場合はエラー(NotFound)         - Content.is_deleted = False         - SessionContentに(session_id, content_id)のデータが存在する         - Question.content_id = content_id         - Question.question_type in [QuestionType.CODING, QuestionType.FILLING, QuestionType.BUG]     - 該当QuestionResultが存在しない場合はエラー(NotFound)         - session_id, question_id, user_idが一致するデータが存在する     - 該当QuestionTestResultが存在しない場合はエラー(NotFound)         - 上記取得したQuestionResult.idと一致するデータが存在する         - is_sample_case = False - 並び順: QuestionTestCase.order昇順 - 処理手順     - 該当QuestionTestResultを取得する     - 最後のポーリングである場合、もし全部のケースが取得できなければ、サーバーエラーと判定し、            QuestionTestResultのquestion_answer_resultをSERVER_ERRORに更新する     - 全部のケースが取得できた場合、結果を返す、 - 備考:     - 一旦ポーリングの最大回数を超えてサーバーエラーに判定されたら、QuestionTestResultのquestion_answer_resultは変えないようにする     - セッション終了後は提出はできるが、点数に反映させない処理が必要です。     (\"app/services/judge_result/judge_result_question.py\"を修正する必要があるかもしれません)
     * セッション問題テストケース実行結果取得
     */
    async getSessionQuestionTestCaseResults(requestParameters: GetSessionQuestionTestCaseResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSessionTestCaseResultsOut> {
        const response = await this.getSessionQuestionTestCaseResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 提出履歴取得 - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理:     - 該当問題が存在しない場合: NotFound - データ取得可能条件:     - Question         - Content.is_deleted = False         - Content.content_type = ContentType.QUESTION         - Question.content_id = content_id     - QuestionTestResult         - question_answer_result not in [QuestionAnswerResult.SCORING, QuestionAnswerResult.SERVER_ERROR] - 処理手順     - 問題を特定     - question_idとuser.idでQuestionResultsを取得(全QuestionResultTypeの問題が対象)     - QuestionResult毎にquestion_test_resultsを取得(採点中とサーバーエラー以外) - 補足     - session_idでの提出のみ取得     - 回答時間降順に並ぶ     - stdin, stdout表示条件(or)         - 「解答者にテストケースを公開フラグがTrue」         - 「プラクティス問題」かつ「問題の公開フラグがTrue」         - 「ラーニング問題」かつ「問題の公開フラグがTrue」
     * セッション過去提出コード一覧取得
     */
    async getSessionQuestionsTestResultsRaw(requestParameters: GetSessionQuestionsTestResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CodeSubmissionHistoryListOut>>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling getSessionQuestionsTestResults.');
        }

        if (requestParameters.contentId === null || requestParameters.contentId === undefined) {
            throw new runtime.RequiredError('contentId','Required parameter requestParameters.contentId was null or undefined when calling getSessionQuestionsTestResults.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/questions/{content_id}/test-results`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))).replace(`{${"content_id"}}`, encodeURIComponent(String(requestParameters.contentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CodeSubmissionHistoryListOutFromJSON));
    }

    /**
     * 提出履歴取得 - 必要権限: [GENERAL_USER, SKILL_CHECK_USER] - 例外処理:     - 該当問題が存在しない場合: NotFound - データ取得可能条件:     - Question         - Content.is_deleted = False         - Content.content_type = ContentType.QUESTION         - Question.content_id = content_id     - QuestionTestResult         - question_answer_result not in [QuestionAnswerResult.SCORING, QuestionAnswerResult.SERVER_ERROR] - 処理手順     - 問題を特定     - question_idとuser.idでQuestionResultsを取得(全QuestionResultTypeの問題が対象)     - QuestionResult毎にquestion_test_resultsを取得(採点中とサーバーエラー以外) - 補足     - session_idでの提出のみ取得     - 回答時間降順に並ぶ     - stdin, stdout表示条件(or)         - 「解答者にテストケースを公開フラグがTrue」         - 「プラクティス問題」かつ「問題の公開フラグがTrue」         - 「ラーニング問題」かつ「問題の公開フラグがTrue」
     * セッション過去提出コード一覧取得
     */
    async getSessionQuestionsTestResults(requestParameters: GetSessionQuestionsTestResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CodeSubmissionHistoryListOut>> {
        const response = await this.getSessionQuestionsTestResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * セッションコード提出履歴一覧取得 - 必要権限：[GENERAL_USER]     - 一般ユーザーのみ実行可 - session_idに紐づくログインユーザーのコード提出履歴を取得する - session_idのセッションが削除済み、存在しない場合NotFound
     * セッションコード提出履歴一覧取得
     */
    async getSessionSubmittedCodeHistoryRaw(requestParameters: GetSessionSubmittedCodeHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SessionSubmitCodeHistoryOut>>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling getSessionSubmittedCodeHistory.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/{session_id}/submit-histories`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SessionSubmitCodeHistoryOutFromJSON));
    }

    /**
     * セッションコード提出履歴一覧取得 - 必要権限：[GENERAL_USER]     - 一般ユーザーのみ実行可 - session_idに紐づくログインユーザーのコード提出履歴を取得する - session_idのセッションが削除済み、存在しない場合NotFound
     * セッションコード提出履歴一覧取得
     */
    async getSessionSubmittedCodeHistory(requestParameters: GetSessionSubmittedCodeHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SessionSubmitCodeHistoryOut>> {
        const response = await this.getSessionSubmittedCodeHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 検定試験タイマースタート - 必要権限: [GENERAL_USER] - 実行可能条件:     - 参加者     - 検定試験     - 未設定・解答開始前・再開待ち - ユーザーステータス：未設定・解答開始前     - user_start_at: 現在時刻     - user_end_at: 削除する（設定なし）     - statusを解答中に変更 - ユーザーステータス：再開待ち     - user_start_at: 現在時刻 - (user_end_at - user_start_at)     - user_end_at: 削除する     - statusを解答中に変更
     * 検定試験タイマースタート
     */
    async startCertificateExamTimerRaw(requestParameters: StartCertificateExamTimerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CertificateExamTimerOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling startCertificateExamTimer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/certificate-exam/{session_id}/timer/start`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateExamTimerOutFromJSON(jsonValue));
    }

    /**
     * 検定試験タイマースタート - 必要権限: [GENERAL_USER] - 実行可能条件:     - 参加者     - 検定試験     - 未設定・解答開始前・再開待ち - ユーザーステータス：未設定・解答開始前     - user_start_at: 現在時刻     - user_end_at: 削除する（設定なし）     - statusを解答中に変更 - ユーザーステータス：再開待ち     - user_start_at: 現在時刻 - (user_end_at - user_start_at)     - user_end_at: 削除する     - statusを解答中に変更
     * 検定試験タイマースタート
     */
    async startCertificateExamTimer(requestParameters: StartCertificateExamTimerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CertificateExamTimerOut> {
        const response = await this.startCertificateExamTimerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 検定試験タイマーストップ - 必要権限: [GENERAL_USER] - 実行可能条件:     - 参加者     - 検定試験     - 解答中 - 処理内容:     - statusを終了に変更     - user_end_atを現在時刻に設定
     * 検定試験タイマーストップ
     */
    async stopCertificateExamTimerRaw(requestParameters: StopCertificateExamTimerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CertificateExamTimerOut>> {
        if (requestParameters.sessionId === null || requestParameters.sessionId === undefined) {
            throw new runtime.RequiredError('sessionId','Required parameter requestParameters.sessionId was null or undefined when calling stopCertificateExamTimer.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/general/sessions/certificate-exam/{session_id}/timer/stop`.replace(`{${"session_id"}}`, encodeURIComponent(String(requestParameters.sessionId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateExamTimerOutFromJSON(jsonValue));
    }

    /**
     * 検定試験タイマーストップ - 必要権限: [GENERAL_USER] - 実行可能条件:     - 参加者     - 検定試験     - 解答中 - 処理内容:     - statusを終了に変更     - user_end_atを現在時刻に設定
     * 検定試験タイマーストップ
     */
    async stopCertificateExamTimer(requestParameters: StopCertificateExamTimerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CertificateExamTimerOut> {
        const response = await this.stopCertificateExamTimerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * 入力パスワードを検証する - 必要権限: [GENERAL_USER] - Response:     - 成功: HTTP_204_NO_CONTENT     - 失敗:         - NotFound             - Sessionが削除されている         - CannotBeExecutedConditionsNotSatisfied             - PW付きセッションではない         - PermissionDenied             - PW不一致 - 処理内容:     1. セッション条件確認         - Session.is_deleted = False             - 不一致の場合: NotFoundを返す         - Session.is_locked_session = True (PW入力必要)             - 不一致の場合: CannotBeExecutedConditionsNotSatisfiedを返す     2. PW認証         - 不一致の場合:             - PermissionDeniedを返す     3. 認証成功         - SessionUserにuser.idが存在する場合:             - SessionUser.is_password_verified = Trueに更新する         - SessionUserにuser.idが存在しない場合:             - 新規登録する
     * 入力パスワードを検証する
     */
    async verifySessionPasswordRaw(requestParameters: VerifySessionPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.sessionCode === null || requestParameters.sessionCode === undefined) {
            throw new runtime.RequiredError('sessionCode','Required parameter requestParameters.sessionCode was null or undefined when calling verifySessionPassword.');
        }

        if (requestParameters.sessionPasswordVerificationIn === null || requestParameters.sessionPasswordVerificationIn === undefined) {
            throw new runtime.RequiredError('sessionPasswordVerificationIn','Required parameter requestParameters.sessionPasswordVerificationIn was null or undefined when calling verifySessionPassword.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/general/sessions/{session_code}/password`.replace(`{${"session_code"}}`, encodeURIComponent(String(requestParameters.sessionCode))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SessionPasswordVerificationInToJSON(requestParameters.sessionPasswordVerificationIn),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * 入力パスワードを検証する - 必要権限: [GENERAL_USER] - Response:     - 成功: HTTP_204_NO_CONTENT     - 失敗:         - NotFound             - Sessionが削除されている         - CannotBeExecutedConditionsNotSatisfied             - PW付きセッションではない         - PermissionDenied             - PW不一致 - 処理内容:     1. セッション条件確認         - Session.is_deleted = False             - 不一致の場合: NotFoundを返す         - Session.is_locked_session = True (PW入力必要)             - 不一致の場合: CannotBeExecutedConditionsNotSatisfiedを返す     2. PW認証         - 不一致の場合:             - PermissionDeniedを返す     3. 認証成功         - SessionUserにuser.idが存在する場合:             - SessionUser.is_password_verified = Trueに更新する         - SessionUserにuser.idが存在しない場合:             - 新規登録する
     * 入力パスワードを検証する
     */
    async verifySessionPassword(requestParameters: VerifySessionPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.verifySessionPasswordRaw(requestParameters, initOverrides);
    }

}
